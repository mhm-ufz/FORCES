!> \file mo_netcdf.f90

!> \brief NetCDF Fortran 90 interface wrapper

!> \details A wrapper around the NetCDF Fortran 90 interface.
!
!> \authors David Schaefer
!> \date Jun 2015

#:include "common.fypp"

#:set KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CHAR_KINDS_TYPES
#:set RANKS = range(0, MAXRANK)

module mo_netcdf

  ! This module provides a thin wrapper around the NetCDF Fortran 90 interface,
  ! following a object-oriented approach.

  ! Written  David Schaefer, Jun 2015
  ! Modified Matthias Cuntz, Jan 2016 - compiled with PGI Fortran rev 15.9 - no automatic allocation of left-hand-side
  ! Modified Ricardo Torres, Feb 2017 - add derived type NcGroup and NcAttributable. NcAttributable is the base derived type,
  !                                     NcGroup and NcVariable are extended from it. NcDataset is extended from NcGroup. No more
  !                                     duplicated routines to set attributes.

  ! License
  ! -------
  ! GNU Lesser General Public License http://www.gnu.org/licenses/

  use mo_kind, only: sp, dp, i1, i2, i4, i8
  use mo_utils, only: gt, lt, ne
  use ieee_arithmetic, only : ieee_is_nan

  ! use, intrinsic :: iso_c_binding, only: i1=>c_int8_t
  ! use, intrinsic :: iso_c_binding, only: i16=>c_short
  ! use, intrinsic :: iso_c_binding, only: i32=>c_int
  ! use, intrinsic :: iso_c_binding, only: i64=>c_long_long
  use netcdf, only : &
          nf90_open, nf90_close, nf90_strerror, nf90_def_dim, nf90_def_var, &
          nf90_put_var, nf90_get_var, nf90_put_att, nf90_get_att, &
          nf90_inquire, nf90_inq_dimid, nf90_inquire_dimension, &
          nf90_inq_varid, nf90_inq_varids, nf90_inquire_variable, nf90_inquire_attribute, &
          nf90_inq_ncid, nf90_inq_grp_parent, nf90_inq_grpname, nf90_def_grp, &
          nf90_rename_dim, nf90_rename_var, nf90_rename_att, nf90_sync, &
          NF90_OPEN, NF90_NETCDF4, NF90_CREATE, NF90_WRITE, NF90_NOWRITE, &
          NF90_BYTE, NF90_SHORT, NF90_INT, NF90_INT64, NF90_FLOAT, NF90_DOUBLE,           &
          NF90_FILL_BYTE, NF90_FILL_SHORT, NF90_FILL_INT, NF90_FILL_FLOAT, NF90_FILL_DOUBLE, &
          NF90_NOERR, NF90_UNLIMITED, NF90_GLOBAL, NF90_SHARE, NF90_HDF5, &
          NF90_64BIT_OFFSET, NF90_CLASSIC_MODEL

  implicit none

  ! --------------------------------------------------------------------------------------
  character(10), parameter :: CF_FILL_VALUE = '_FillValue'
  character(11), parameter :: CF_VALID_RANGE = 'valid_range'
  character(9), parameter :: CF_VALID_MIN = 'valid_min'
  character(9), parameter :: CF_VALID_MAX = 'valid_max'
  integer(i4), parameter :: CF_USE_FILL_VALUE = 1_i4
  integer(i4), parameter :: CF_USE_VALID_MIN = 2_i4
  integer(i4), parameter :: CF_USE_VALID_MAX = 3_i4
  integer(i4), parameter :: CF_USE_VALID_RANGE = 4_i4
  integer(i4), parameter :: CF_USE_NAN = 5_i4

  type, abstract :: NcBase

    integer(i4) :: id

  contains

    procedure(getNameInterface), deferred :: getName
    procedure(getParentInterface), deferred :: getParent

  end type NcBase

  type, abstract, extends(NcBase) :: NcAttributable

  contains

    procedure, public :: hasAttribute
    procedure, public :: renameAttribute
    procedure, private :: getAttributableIds

#:for kind, type in REAL_KINDS_TYPES + INT_KINDS_TYPES
  #:for rank in [0, 1]
    procedure, private :: setAttribute_${rank}$d_${kind}$
    generic, public :: setAttribute => setAttribute_${rank}$d_${kind}$
    procedure, private :: getAttribute_${rank}$d_${kind}$
    generic, public :: getAttribute => getAttribute_${rank}$d_${kind}$
  #:endfor
#:endfor
#:for kind, type in CHAR_KINDS_TYPES
  #:for rank in [0]
    procedure, private :: setAttribute_${rank}$d_${kind}$
    generic, public :: setAttribute => setAttribute_${rank}$d_${kind}$
    procedure, private :: getAttribute_${rank}$d_${kind}$
    generic, public :: getAttribute => getAttribute_${rank}$d_${kind}$
  #:endfor
#:endfor

  end type NcAttributable

  ! --------------------------------------------------------------------------------------

  type, extends(NcAttributable) :: NcGroup

  contains

    ! getter
    procedure, private :: getVariableIds
    procedure, public :: getVariables
    procedure, public :: getUnlimitedDimension
    procedure, public :: getNoVariables

    procedure, private :: getDimensionByName
    procedure, private :: getDimensionById

    procedure, public :: getParent => getGroupParent
    procedure, public :: getName => getGroupName
    procedure, public :: getGroup => getGroupByName
    procedure, public :: getVariable => getVariableByName
    generic, public :: getDimension => &
            getDimensionById, &
            getDimensionByName

    ! checker
    procedure, public :: hasVariable
    procedure, public :: hasDimension
    procedure, public :: hasGroup
    procedure, public :: isUnlimited => isDatasetUnlimited

    ! setter
    procedure, public  :: setGroup
    !procedure, private :: setDimension_1Dbounds
    !procedure, private :: setDimension_2Dbounds
    procedure, private :: setDimension_ => setDimension_i4_
    procedure, public :: setDimension => setDimension_i4
    procedure, private :: setVariableWithTypes
    procedure, private :: setVariableWithNames
    procedure, private :: setVariableWithIds

    generic, public :: setVariable => &
            setVariableWithNames, &
            setVariableWithTypes, &
            setVariableWithIds

  end type NcGroup

  interface NcGroup
    procedure newNcGroup
  end interface NcGroup

  ! --------------------------------------------------------------------------------------

  type, extends(NcGroup) :: NcDataset

    character(256) :: fname !> Filename of the opened dataset
    character(1) :: mode  !> File open mode

  contains

    procedure, public :: sync
    procedure, public :: close

  end type NcDataset

  interface NcDataset
    procedure newNcDataset
  end interface NcDataset

  ! --------------------------------------------------------------------------------------

  type, extends(NcBase) :: NcDimension

    type(NcGroup) :: parent  !> The dimension's parent
  contains
    procedure, public :: renameDimension
    procedure, public :: getParent => getDimensionParent
    procedure, public :: getName => getDimensionName
    procedure, public :: getLength => getDimensionLength
    procedure, public :: isUnlimited => isUnlimitedDimension
  end type NcDimension

  interface NcDimension
    procedure newNcDimension
  end interface NcDimension
  ! --------------------------------------------------------------------------------------

  type, extends(NcAttributable) :: NcVariable
    type(NcGroup) :: parent   !> The variables's parent

  contains

    procedure, public :: renameVariable
    procedure, public :: getParent => getVariableParent
    procedure, public :: getName => getVariableName
    procedure, private :: getSlicingShape

#:for kind, type in REAL_KINDS_TYPES + INT_KINDS_TYPES
  #:for rank in RANKS
    procedure, private :: setData_${rank}$d_${kind}$
    generic, public :: setData => setData_${rank}$d_${kind}$
    procedure, private :: getData_${rank}$d_${kind}$
    generic, public :: getData => getData_${rank}$d_${kind}$
  #:endfor
    procedure, private :: getCFAttributes_${kind}$
    generic, public :: getCFAttributes => getCFAttributes_${kind}$
    procedure, private :: setVariableFillValue_${kind}$
    generic, public :: setFillValue => setVariableFillValue_${kind}$
    procedure, private :: getVariableFillValue_${kind}$
    generic, public :: getFillValue => getVariableFillValue_${kind}$
#:endfor

    procedure, public :: getNoDimensions

    procedure, public :: getDimensions => getVariableDimensions

    procedure, public :: getRank => getVariableRank

    procedure, public :: getShape => getVariableShape

    procedure, public :: getDtype => getVariableDtype

    procedure, public :: isUnlimited => isUnlimitedVariable


  end type NcVariable

  interface NcVariable
    procedure newNcVariable
  end interface NcVariable
  ! --------------------------------------------------------------------------------------

  ! abstract interfaces
  interface
    function getNameInterface(self)
      import NcBase
      class(NcBase), intent(in) :: self
      character(len = 256) :: getNameInterface
    end function getNameInterface

    function getParentInterface(self)
      import NcBase, NcGroup
      class(NcBase), intent(in) :: self
      type(NcGroup) :: getParentInterface
    end function getParentInterface
  end interface

  interface operator (==)
    procedure equalNcBases
  end interface operator (==)

contains

  function newNcDataset(fname, fmode, cmode) result(out)
    character(*), intent(in) :: fname
    character(1), intent(in) :: fmode
    character(*), intent(inout), optional :: cmode
    integer(i4) :: status
    type(NcDataset) :: out

    select case(fmode)
    case("w")
      status = nf90_create(trim(fname), getCreationMode(cmode), out%id)
    case("r")
      status = nf90_open(trim(fname), NF90_NOWRITE, out%id)
    case("a")
      status = nf90_open(trim(fname), NF90_WRITE, out%id)
    case default
      write(*, *) "Mode argument must be in 'w','r','a' ! "
      stop 1
    end select
    call check(status, "Failed to open file: " // fname)

    out%fname = fname
    out%mode = fmode
  end function newNcDataset

  function newNcVariable(id, parent) result(out)
    integer(i4), intent(in) :: id
    type(NcGroup), intent(in) :: parent
    type(NcVariable) :: out

    out%id = id
    out%parent = parent
  end function newNcVariable

  function newNcDimension(id, parent) result(out)
    integer(i4), intent(in) :: id
    type(NcGroup), intent(in) :: parent
    type(NcDimension) :: out

    out%id = id
    out%parent = parent
  end function newNcDimension

  function newNcGroup(id) result(out)
    integer(i4), intent(in) :: id
    type(NcGroup) :: out

    out%id = id
  end function newNcGroup

  subroutine sync(self)
    class(NcDataset) :: self

    call check(nf90_sync(self%id), "Failed to sync file: " // self%fname)
  end subroutine sync

  subroutine close(self)
    class(NcDataset) :: self

    call check(nf90_close(self%id), "Failed to close file: " // self%fname)
  end subroutine close

  function setGroup(self, name)
    class(NcGroup), intent(inout) :: self
    character(*), intent(in) :: name
    integer(i4) :: id
    type(NcGroup) :: setGroup

    call check(nf90_def_grp(self%id, name, id), "Failed to create new group: " // name)
    setGroup = NcGroup(id)
  end function setGroup

  function getGroupParent(self)
    class(NcGroup), intent(in) :: self
    integer(i4) :: id
    type(NcGroup) :: getGroupParent

    call check(nf90_inq_grp_parent(self%id, id), "Failed to get parent group of: " // self%getName())
    getGroupParent = NcGroup(id)
  end function getGroupParent

  function getGroupName(self)
    class(NcGroup), intent(in) :: self
    character(256) :: getGroupName

    call check(nf90_inq_grpname(self%id, getGroupName), "Failed to inquire group name")
  end function getGroupName

  function getNoVariables(self)
    class(NcGroup), intent(in) :: self
    integer(i4) :: getNoVariables

    call check(nf90_inquire(self%id, nvariables = getNoVariables), "Failed inquire number of variables")
  end function getNoVariables

  function getDimensionParent(self)
    class(NcDimension), intent(in) :: self
    type(NcGroup) :: getDimensionParent

    getDimensionParent = self%parent
  end function getDimensionParent

  function getVariableParent(self)
    class(NcVariable), intent(in) :: self
    type(NcGroup) :: getVariableParent

    getVariableParent = self%parent
  end function getVariableParent

  function getVariableIds(self)
    class(NcGroup), intent(in) :: self
    integer(i4), dimension(:), allocatable :: getVariableIds
    integer(i4) :: tmp

    allocate(getVariableIds(self%getNoVariables()))
    call check(nf90_inq_varids(self%id, tmp, getVariableIds), "Failed to inquire variable ids")
  end function getVariableIds

  function getVariables(self)
    class(NcGroup), intent(in) :: self
    type(NcVariable), dimension(:), allocatable :: getVariables
    integer(i4), dimension(:), allocatable :: varids
    integer(i4) :: i, nvars

    nvars = self%getNoVariables()
    allocate(getVariables(nvars), varids(nvars))

    varids = self%getVariableIds()
    do i = 1, size(varids)
      getVariables(i) = NcVariable(varids(i), self)
    end do

  end function getVariables

  function getDimensionName(self)
    class(NcDimension), intent(in) :: self
    character(len = 256) :: getDimensionName

    call check(nf90_inquire_dimension(self%parent%id, self%id, name = getDimensionName), &
            "Failed to inquire dimension name")
  end function getDimensionName

  function getDimensionLength(self)
    class(NcDimension), intent(in) :: self
    integer(i4) :: getDimensionLength

    call check(nf90_inquire_dimension(self%parent%id, self%id, len = getDimensionLength), &
            "Failed to inquire dimension: " // self%getName())
  end function getDimensionLength

  function isDatasetUnlimited(self)
    class(NcGroup), intent(in) :: self
    logical :: isDatasetUnlimited
    integer(i4) :: dimid

    call check(nf90_inquire(self%id, unlimitedDimId = dimid), &
            "Failed to inquire group " // self%getName())
    isDatasetUnlimited = (dimid /= -1)
  end function isDatasetUnlimited

  function getUnlimitedDimension(self)
    class(NcGroup), intent(in) :: self
    type(NcDimension) :: getUnlimitedDimension
    integer(i4) :: dimid

    call check(nf90_inquire(self%id, unlimitedDimId = dimid), &
            "Failed to inquire group " // self%getName())

    if (dimid == -1) then
      write(*, *) "Dataset has no unlimited dimension"
      stop 1
    end if

    getUnlimitedDimension = self%getDimension(dimid)
  end function getUnlimitedDimension

  function equalNcBases(left, right) result(out)
    class(NcBase), intent(in) :: left, right
    logical :: out

    out = (left%id == right%id)
  end function equalNcBases

  function isUnlimitedDimension(self)
    class(NcDimension), intent(in) :: self
    logical :: isUnlimitedDimension

    isUnlimitedDimension = .false.
    if (self%parent%isUnlimited()) then
      isUnlimitedDimension = (self == self%parent%getUnlimitedDimension())
    end if
  end function isUnlimitedDimension

  function setDimension_i4_(self, name, length)
    class(NcGroup), intent(in) :: self
    character(*)  , intent(in) :: name
    integer(i4)   , intent(in), optional :: length

    type(NcDimension)          :: setDimension_i4_
    integer(i4)                :: id, dimlength

    dimlength = NF90_UNLIMITED
    if (present(length)) then
      if (length <= 0) then
       dimlength = NF90_UNLIMITED
      else
        dimlength = length
      end if
    end if

    call check(nf90_def_dim(self%id, name, dimlength, id), &
         "Failed to create dimension: " // name)

    setDimension_i4_ = NcDimension(id, self)

  end function setDimension_i4_

  function setDimension_i4(self, name, length, bounds, reference, attribute_names, attribute_values, &
                        centersDim1, centersDim2, cornersDim1, cornersDim2, subDimSizes, units)
    class(NcGroup), intent(in) :: self
    character(*)  , intent(in) :: name
    integer(i4)   , intent(in), optional :: length
    real(dp)      , intent(in), optional, dimension(:) :: bounds
    integer(i4)   , intent(in), optional :: reference
    character(256) , intent(in), optional, dimension(:) :: attribute_names
    character(2048) , intent(in), optional, dimension(:) :: attribute_values
    real(dp)      , intent(in), optional, dimension(:) :: centersDim1
    real(dp)      , intent(in), optional, dimension(:) :: centersDim2
    real(dp)      , intent(in), optional, dimension(:,:) :: cornersDim1
    real(dp)      , intent(in), optional, dimension(:,:) :: cornersDim2
    integer(i4)   , intent(in), optional, dimension(:) :: subDimSizes
    character(256), intent(in), optional :: units

    type(NcDimension)          :: setDimension_i4, bnds_dim, cornerDim, rankDim
    type(NcVariable)           :: nc_var
    integer(i4)                :: dimlength, reference_default, iAtt, iBound
    character(256)              :: dim_bound_name
    real(dp), allocatable, dimension(:, :) :: bound_data
    integer(i4), allocatable, dimension(:) :: imask_data

    if (present(centersDim1) .and. present(centersDim2) .and. present(cornersDim1) .and. present(cornersDim2) &
             .and. present(subDimSizes) .and. present(units)) then
      ! set the new ncDimension (integer values and name)
      setDimension_i4 = self%setDimension_('grid_size', size(centersDim1))
      cornerDim = self%setDimension_('grid_corners', size(cornersDim1, 1))
      rankDim = self%setDimension_('grid_rank', size(subDimSizes))
      ! here we set the reference to ncDimension for labelled ncDimension which in fact is a variable
      nc_var = self%setVariable('grid_center_lon', "f64", [setDimension_i4])
      call nc_var%setData(centersDim1)
      call nc_var%setAttribute('units', trim(units))
      nc_var = self%setVariable('grid_center_lat', "f64", [setDimension_i4])
      call nc_var%setData(centersDim2)
      call nc_var%setAttribute('units', trim(units))
      nc_var = self%setVariable('grid_corner_lon', "f64", [cornerDim, setDimension_i4])
      call nc_var%setData(cornersDim1)
      call nc_var%setAttribute('units', trim(units))
      nc_var = self%setVariable('grid_corner_lat', "f64", [cornerDim, setDimension_i4])
      call nc_var%setData(cornersDim2)
      call nc_var%setAttribute('units', trim(units))
      nc_var = self%setVariable('grid_dims', "i32", [rankDim])
      call nc_var%setData(subDimSizes)
      ! set all values to 1 (True) for mask
      nc_var = self%setVariable('grid_imask', "i32", [setDimension_i4])
      allocate(imask_data(size(centersDim1)))
      imask_data = 1_i4
      call nc_var%setData(imask_data)
      deallocate(imask_data)
      call nc_var%setAttribute('units', 'unitless')

    else
      ! set the new ncDimension (integer values and name)
      setDimension_i4 = self%setDimension_(name, length)

      if (present(bounds)) then
        ! init
        dimlength = size(bounds)
        reference_default = 1_i4
        if (present(reference)) then
          reference_default = reference
        end if
        ! here we set the reference to ncDimension for labelled ncDimension which in fact is a variable
        nc_var = self%setVariable(name, "f64", [setDimension_i4])
        ! write the data based on the type of reference
        select case(reference_default)
        case(0_i4)
          ! set the start values
          call nc_var%setData(bounds(1:dimlength - 1))
        case(1_i4)
          ! set the center values
          call nc_var%setData((bounds(2:dimlength) + bounds(1:dimlength-1)) / 2.0_dp)
        case(2_4)
          ! set the end values
          call nc_var%setData(bounds(2:dimlength))
        case default
          write(*,*) "reference id for set_Dimension is unknown"
          stop 1
        end select
        ! set attributes
        ! already set attributes
        if (present(attribute_names) .and. present(attribute_values)) then
          do iAtt = 1, size(attribute_names)
            call nc_var%setAttribute(trim(attribute_names(iAtt)), &
                    trim(attribute_values(iAtt)))
          end do
        end if
        ! --- bounds ---
        ! allocate array for data
        allocate(bound_data(2_i4, dimlength-1))
        ! create dimension name for bounds
        dim_bound_name = trim(name) // "_bnds"
        ! set the attribute
        call nc_var%setAttribute('bounds', trim(dim_bound_name))
        ! set the dimensions used for the bounds array
        if (self%hasDimension("bnds")) then
          ! add it to our bounds of ncDimensions for the current array
          bnds_dim = self%getDimension("bnds")
        else
          bnds_dim = self%setDimension_("bnds", 2)
        end if
        nc_var = self%setVariable(dim_bound_name, "f64", [bnds_dim, setDimension_i4])
        do iBound = 1, dimlength-1
          bound_data(1, iBound) = bounds(iBound)
          bound_data(2, iBound) = bounds(iBound + 1)
        end do
        call nc_var%setData(bound_data)
        deallocate(bound_data)

      end if

    end if

  end function setDimension_i4

  function hasVariable(self, name)
    class(NcGroup), intent(in) :: self
    character(*), intent(in) :: name
    logical :: hasVariable
    integer(i4) :: tmpid

    hasVariable = (nf90_inq_varid(self%id, name, tmpid) == NF90_NOERR)
  end function hasVariable

  function hasDimension(self, name)
    class(NcGroup), intent(in) :: self
    character(*), intent(in) :: name
    logical :: hasDimension
    integer(i4) :: tmpid

    hasDimension = (nf90_inq_dimid(self%id, name, tmpid) == NF90_NOERR)
  end function hasDimension

  function hasGroup(self, name)
    class(NcGroup), intent(in) :: self
    character(*), intent(in) :: name
    logical :: hasGroup
    integer(i4) :: tmpid

    hasGroup = (nf90_inq_ncid(self%id, name, tmpid) == NF90_NOERR)
  end function hasGroup

  function setVariableWithIds(self, name, dtype, dimensions, contiguous, &
          chunksizes, deflate_level, shuffle, fletcher32, endianness, &
          cache_size, cache_nelems, cache_preemption)
    class(NcGroup), intent(in) :: self
    character(*), intent(in) :: name
    character(*), intent(in) :: dtype
    integer(i4), intent(in) :: dimensions(:)
    logical, intent(in), optional :: contiguous, shuffle, fletcher32
    integer(i4), intent(in), optional :: endianness, deflate_level, cache_size, &
            cache_nelems, cache_preemption, chunksizes(:)
    type(NcVariable) :: setVariableWithIds
    integer(i4) :: varid, status

    status = nf90_def_var(self%id, name, getDtypeFromString(dtype), dimensions, varid, contiguous, &
            chunksizes, deflate_level, shuffle, fletcher32, endianness, &
            cache_size, cache_nelems, cache_preemption)
    call check(status, "Failed to create variable: " // name)
    setVariableWithIds = NcVariable(varid, self)
  end function setVariableWithIds

  function setVariableWithNames(self, name, dtype, dimensions, contiguous, &
          chunksizes, deflate_level, shuffle, fletcher32, endianness, &
          cache_size, cache_nelems, cache_preemption)

    class(NcGroup), intent(in) :: self
    character(*), intent(in) :: name
    character(*), intent(in) :: dtype
    character(*), intent(in) :: dimensions(:)
    logical, intent(in), optional :: contiguous, shuffle, fletcher32
    integer(i4), intent(in), optional :: endianness, deflate_level, cache_size, &
            cache_nelems, cache_preemption, chunksizes(:)
    type(NcVariable) :: setVariableWithNames
    type(NcDimension) :: dim
    integer(i4) :: i, dimids(size(dimensions))

    do i = 1, size(dimensions)
      dim = self%getDimension(dimensions(i))
      dimids(i) = dim%id
    end do

    setVariableWithNames = setVariableWithIds(self, name, dtype, dimids, contiguous, &
            chunksizes, deflate_level, shuffle, fletcher32, endianness, &
            cache_size, cache_nelems, cache_preemption)
  end function setVariableWithNames

  function setVariableWithTypes(self, name, dtype, dimensions, contiguous, &
          chunksizes, deflate_level, shuffle, fletcher32, endianness, &
          cache_size, cache_nelems, cache_preemption)
    class(NcGroup), intent(in) :: self
    character(*), intent(in) :: name
    character(*), intent(in) :: dtype
    type(NcDimension), intent(in) :: dimensions(:)
    logical, intent(in), optional :: contiguous, shuffle, fletcher32
    integer(i4), intent(in), optional :: endianness, deflate_level, cache_size, &
            cache_nelems, cache_preemption, chunksizes(:)
    type(NcVariable) :: setVariableWithTypes
    type(NcDimension) :: dim
    integer(i4) :: i, dimids(size(dimensions))

    do i = 1, size(dimensions)
      dim = dimensions(i)
      dimids(i) = dim%id
    end do

    setVariableWithTypes = setVariableWithIds(self, name, dtype, dimids, contiguous, &
            chunksizes, deflate_level, shuffle, fletcher32, endianness, &
            cache_size, cache_nelems, cache_preemption)
  end function setVariableWithTypes

  function getDimensionById(self, id)
    class(NcGroup), intent(in) :: self
    integer(i4) :: id
    type(NcDimension) :: getDimensionById
    character(32) :: msg, name

    write(msg, *) id
    call check(nf90_inquire_dimension(self%id, id, name), &
            "Could not inquire dimension: " // msg)
    getDimensionById = NcDimension(id, self)
  end function getDimensionById

  function getDimensionByName(self, name)
    class(NcGroup), intent(in) :: self
    character(*) :: name
    type(NcDimension) :: getDimensionByName
    integer(i4) :: id

    call check(nf90_inq_dimid(self%id, name, id), &
            "Could not inquire dimension: " // name)
    getDimensionByName = self%getDimensionById(id)
  end function getDimensionByName

  function getGroupByName(self, name)
    class(NcGroup), intent(in) :: self
    character(*), intent(in) :: name
    type(NcGroup) :: getGroupByName
    integer(i4) :: id

    call check(nf90_inq_ncid(self%id, name, id), &
            "Could not inquire variable: " // name)
    getGroupByName = NcGroup(id)
  end function getGroupByName

  function getVariableByName(self, name)
    class(NcGroup), intent(in) :: self
    character(*), intent(in) :: name
    type(NcVariable) :: getVariableByName
    integer(i4) :: id

    call check(nf90_inq_varid(self%id, name, id), &
            "Could not inquire variable: " // name)
    getVariableByName = NcVariable(id, self)

  end function getVariableByName

  function getVariableName(self)
    class(NcVariable), intent(in) :: self
    character(len = 256) :: getVariableName

    call check(nf90_inquire_variable(self%parent%id, self%id, name = getVariableName), &
            "Could not inquire variable name")
  end function getVariableName

  function getNoDimensions(self)
    class(NcVariable), intent(in) :: self
    integer(i4) :: getNoDimensions

    call check(nf90_inquire_variable(self%parent%id, self%id, ndims = getNoDimensions), &
            "Could not inquire variable: " // self%getName())
  end function getNoDimensions

  function getVariableDimensions(self)
    class(NcVariable), intent(in) :: self
    type(NcDimension), allocatable :: getVariableDimensions(:)
    integer(i4), allocatable :: dimids(:)
    integer(i4) :: ii, ndims

    ndims = self%getNoDimensions()
    allocate(dimids(ndims), getVariableDimensions(ndims))
    call check(nf90_inquire_variable(self%parent%id, self%id, dimids = dimids), &
            "Could not inquire variable: " // self%getName())

    do ii = 1, ndims
      getVariableDimensions (ii) = self%parent%getDimension(dimids(ii))
    end do
  end function getVariableDimensions

  function getVariableShape(self)
    class(NcVariable), intent(in) :: self
    integer(i4), allocatable :: getVariableShape(:)
    type(NcDimension), allocatable :: dims(:)
    integer(i4) :: ii, ndims

    ndims = self%getNoDimensions()
    allocate(getVariableShape(ndims), dims(ndims))

    dims = self%getDimensions()
    do ii = 1, size(dims)
      getVariableShape(ii) = dims(ii)%getLength()
    end do
  end function getVariableShape

  function getVariableRank(self)
    class(NcVariable), intent(in) :: self
    integer(i4) :: getVariableRank

    getVariableRank = size(self%getDimensions())
  end function getVariableRank

  function getVariableDtype(self)
    class(NcVariable), intent(in) :: self
    integer(i4) :: dtype
    character(3) :: getVariableDtype

    call check(nf90_inquire_variable(self%parent%id, self%id, xtype = dtype), &
            "Could not inquire variable: " // self%getName())
    getVariableDtype = getDtypeFromInteger(dtype)
  end function getVariableDtype

  function isUnlimitedVariable(self)
    class(NcVariable), intent(in) :: self
    logical :: isUnlimitedVariable
    type(NcDimension), allocatable :: dims(:)
    type(NcDimension) :: dim
    integer(i4) :: ii

    allocate(dims(self%getNoDimensions()))

    isUnlimitedVariable = .false.
    dims = self%getDimensions()

    do ii = 1, size(dims)
      dim = dims(ii)
      if (dim%isUnlimited()) then
        isUnlimitedVariable = .true.
      end if
    end do
  end function isUnlimitedVariable

  logical function hasAttribute(self, name)
    class(NcAttributable), intent(in) :: self
    character(*), intent(in) :: name
    integer(i4) :: status

    select type (self)
    class is (NcGroup)
      status = nf90_inquire_attribute(self%id, NF90_GLOBAL, name)
    class is (NcVariable)
      status = nf90_inquire_attribute(self%parent%id, self%id, name)
    end select

    hasAttribute = (status == NF90_NOERR)
  end function hasAttribute

#:def setAttribute_template(kind, type, rank)
  subroutine setAttribute_${rank}$d_${kind}$(self, name, data)
    class(NcAttributable), intent(in) :: self
    character(len=*), intent(in) :: name
    ${type}$, intent(in) :: data${ranksuffix(rank)}$
    integer(i4) :: ids(2)

    ids = self%getAttributableIds()
    call check(nf90_put_att(ids(1), ids(2), name, data), &
            "Failed to write attribute: " // name)

  end subroutine setAttribute_${rank}$d_${kind}$

#:enddef setAttribute_template

#:def getAttribute_template(kind, type, rank)
  subroutine getAttribute_${rank}$d_${kind}$(self, name, avalue)
    class(NcAttributable), intent(in) :: self
    character(len=*), intent(in) :: name
    ${type}$, intent(out) :: avalue${ranksuffix(rank)}$
    integer(i4) :: length, ids(2)

    ids = self%getAttributableIds()
    call check(nf90_inquire_attribute(ids(1), ids(2), name, len = length), &
            "Could not inquire attribute " // name)
    call check(nf90_get_att(ids(1), ids(2), name, avalue), &
            "Could not read attribute " // name)

  end subroutine getAttribute_${rank}$d_${kind}$

#:enddef getAttribute_template

#:for kind, type in REAL_KINDS_TYPES + INT_KINDS_TYPES
  #:for rank in [0, 1]
    $:setAttribute_template(kind, type, rank)
    $:getAttribute_template(kind, type, rank)
  #:endfor
#:endfor
#:for kind, type in CHAR_KINDS_TYPES
  #:for rank in [0]
    $:setAttribute_template(kind, type, rank)
    $:getAttribute_template(kind, type, rank)
  #:endfor
#:endfor

  function getAttributableIds(self)
    class(NcAttributable), intent(in) :: self
    integer(i4) :: getAttributableIds(2)
    select type(self)
    class is (NcGroup)
      getAttributableIds(1) = self%id
      getAttributableIds(2) = NF90_GLOBAL
    class is (NcVariable)
      getAttributableIds(1) = self%parent%id
      getAttributableIds(2) = self%id
    end select
  end function getAttributableIds

  subroutine renameAttribute(self, oldname, newname)
    class(NcAttributable), intent(inout) :: self
    character(len = *), intent(in) :: oldname, newname
    integer(i4) :: ids(2)
    ids = self%getAttributableIds()
    call check(nf90_rename_att(ids(1), ids(2), oldname, newname), "Failed to rename attribute: " // oldname)
  end subroutine renameAttribute

  subroutine renameVariable(self, name)
    class(NcVariable), intent(inout) :: self
    character(len = *), intent(in) :: name
    call check(nf90_rename_var(self%parent%id, self%id, name), "Failed to rename variable: " // self%getName())
  end subroutine renameVariable

  subroutine renameDimension(self, name)
    class(NcDimension), intent(inout) :: self
    character(len = *), intent(in) :: name
    call check(nf90_rename_dim(self%parent%id, self%id, name), "Failed to rename dimension: " // self%getName())
  end subroutine renameDimension

#:def setFillValue_template(kind, type)
  subroutine setVariableFillValue_${kind}$(self, fvalue)
    class(NcVariable), intent(inout) :: self
    ${type}$, intent(in) :: fvalue

    if (.not. self%hasAttribute(CF_FILL_VALUE)) then
      call self%setAttribute(CF_FILL_VALUE, fvalue)
    end if

  end subroutine setVariableFillValue_${kind}$

#:enddef setFillValue_template

#:def getFillValue_template(kind, type)
  subroutine getVariableFillValue_${kind}$(self, fvalue)
    class(NcVariable), intent(in) :: self
    ${type}$, intent(out) :: fvalue

    if (self%hasAttribute(CF_FILL_VALUE)) then
      call self%getAttribute(CF_FILL_VALUE, fvalue)
    else
      $: '      fvalue = ' + {'i1': 'NF90_FILL_BYTE', 'i2': 'NF90_FILL_SHORT', 'i4': 'NF90_FILL_INT', 'i8': 'NF90_FILL_INT', 'sp': 'NF90_FILL_FLOAT', 'dp': 'NF90_FILL_DOUBLE', }[kind]
    end if

  end subroutine getVariableFillValue_${kind}$

#:enddef getFillValue_template

#:def getCFAttributes_template(kind, type)
  subroutine getCFAttributes_${kind}$(self, minValue, maxValue, fillValue, flagMissing)
    class(NcVariable), intent(in) :: self
    ${type}$, intent(out) :: minValue, maxValue, fillValue
    integer(i4), intent(out) :: flagMissing

    ${type}$ :: valid_range(2)

    flagMissing = CF_USE_FILL_VALUE
    call self%getFillValue(fillValue)
    if (self%hasAttribute(CF_VALID_RANGE)) then
      flagMissing = CF_USE_VALID_RANGE
      call self%getAttribute(CF_VALID_RANGE, valid_range)
      minValue = valid_range(1)
      maxValue = valid_range(2)
    else if (self%hasAttribute(CF_VALID_MIN)) then
      flagMissing = CF_USE_VALID_MIN
      call self%getAttribute(CF_VALID_MIN, minValue)
    else if (self%hasAttribute(CF_VALID_MAX)) then
      flagMissing = CF_USE_VALID_MAX
      call self%getAttribute(CF_VALID_MAX, maxValue)
    end if

  end subroutine getCFAttributes_${kind}$

#:enddef getCFAttributes_template

#:def getData_template(kind, type, rank)
  subroutine getData_${rank}$d_${kind}$(self, data, start, cnt, stride, map, mask)
    class(NcVariable), intent(in) :: self
    ${type}$, intent(out), allocatable :: data${ranksuffix(rank)}$
    integer(i4), intent(in), optional :: start(:), cnt(:), stride(:), map(:)
    logical, intent(out), allocatable, optional :: mask${ranksuffix(rank)}$

    integer(i4) :: flagMissing
    ${type}$ :: fillValue, minValue, maxValue
#: if rank > 0
    integer(i4), allocatable :: slcshape(:), datashape(:)

    slcshape = self%getSlicingShape(start, cnt, stride)
    datashape = getReadShape(slcshape, size(shape(data)))
$: '      allocate(data(' + ('datashape({}), '*rank).format(*list(range(1, rank+1)))[:-2] + '))'
    call check (nf90_get_var(self%parent%id, self%id, data, start, cnt, stride, map), &
            "Could not read data from variable: " // trim(self%getName()))
#: else
    ${type}$ :: tmp(1)

    call check (nf90_get_var(self%parent%id, self%id, tmp, start, cnt, stride, map), &
            "Could not read data from variable: " // trim(self%getName()))
    data = tmp(1)
#: endif
    if (present(mask)) then
#: if rank > 0
$: '      allocate(mask(' + ('datashape({}), '*rank).format(*list(range(1, rank+1)))[:-2] + '))'
#: endif
      mask =.true.
      call self%getCFAttributes(minValue, maxValue, fillValue, flagMissing)
      select case(flagMissing)
#: if kind in INT_KINDS
      case(CF_USE_FILL_VALUE)
        mask = .not. (data == fillValue)
      case(CF_USE_VALID_MIN)
        mask = data >= minValue
      case(CF_USE_VALID_MAX)
        mask = data <= maxValue
      case(CF_USE_VALID_RANGE)
        mask = (data <= maxValue) .and. (data >= minValue)
#: else
      case(CF_USE_FILL_VALUE)
        mask = ne(data, fillValue)
      case(CF_USE_NAN)
        mask = .not. ieee_is_nan(data)
      case(CF_USE_VALID_MIN)
        mask = gt(data, minValue)
      case(CF_USE_VALID_MAX)
        mask = lt(data, maxValue)
      case(CF_USE_VALID_RANGE)
        mask = lt(data, maxValue) .and. gt(data, minValue)
#: endif
      end select
    end if

  end subroutine getData_${rank}$d_${kind}$

#:enddef getData_template

#:def setData_template(kind, type, rank)
  #! the cnt, stride and map args are valid only for 1d varities, they were originally also not appearing in dummy args
  subroutine setData_${rank}$d_${kind}$(self, values, start, cnt, stride, map)
    class(NcVariable), intent(in) :: self
    ${type}$, intent(in) :: values${ranksuffix(rank)}$
    integer(i4), intent(in), optional :: start(:), cnt(:), stride(:), map(:)
#: if rank > 0
    call check(nf90_put_var(self%parent%id, self%id, values, start, cnt, stride, map), &
#: else
    call check(nf90_put_var(self%parent%id, self%id, values, start), &
#: endif
            "Failed to write data into variable: " // trim(self%getName()))

  end subroutine setData_${rank}$d_${kind}$

#:enddef setData_template

#:for kind, type in REAL_KINDS_TYPES + INT_KINDS_TYPES
  #:for rank in RANKS
    $:getData_template(kind, type, rank)
    $:setData_template(kind, type, rank)
  #:endfor
  $:getFillValue_template(kind, type)
  $:getCFAttributes_template(kind, type)
  $:setFillValue_template(kind, type)
#:endfor

  function getSlicingShape(self, instart, incnt, instride) result(out)
    class(NcVariable), intent(in) :: self
    integer(i4), intent(in), optional :: instart(:), incnt(:), instride(:)
    integer(i4), allocatable :: out(:)

    out = self%getShape()

    if (present(incnt)) then
      out(:size(incnt)) = incnt
      ! out = incnt
    else
      if (present(instart)) then
        out(:size(instart)) = out(:size(instart)) - (instart - 1)
      end if
      if (present(instride)) then
        out(:size(instride)) = out(:size(instride)) / instride
      end if
    end if

  end function getSlicingShape

  function getReadShape(slcshape, outrank) result(out)
    integer(i4), intent(in) :: slcshape(:)
    integer(i4), intent(in) :: outrank
    integer(i4) :: naxis
    integer(i4), allocatable :: out(:)

    naxis = count(slcshape > 1)

    if (all(slcshape == 1)) then
      ! return 1-element array
      allocate(out(size(slcshape)))
      out(:) = 1
    else if (size(slcshape) == outrank) then
      ! sizes fit
      out = slcshape
    else if (naxis == outrank) then
      out = pack(slcshape, slcshape > 1)
      ! else if (naxis .lt. outrank) then
      ! would be nice...
    else
      write(*, *) "Given indices do not match output variable rank!"
      stop 1
    end if
  end function getReadShape

  function getDtypeFromString(dtype)
    integer(i4) :: getDtypeFromString
    character(*)         :: dtype

    select case(dtype)
    case("f32")
       getDtypeFromString = NF90_FLOAT
    case("f64")
       getDtypeFromString = NF90_DOUBLE
    case("i8")
       getDtypeFromString = NF90_BYTE
    case("i16")
       getDtypeFromString = NF90_SHORT
    case("i32")
       getDtypeFromString = NF90_INT
    case("i64")
       getDtypeFromString = NF90_INT64
    case default
       write(*,*) "Datatype not understood: ", dtype
       stop 1
    end select
  end function getDtypeFromString

  function getDtypeFromInteger(dtype)
    character(3) :: getDtypeFromInteger
    integer(i4) :: dtype

    select case(dtype)
    case(NF90_FLOAT)
       getDtypeFromInteger = "f32"
    case(NF90_DOUBLE)
       getDtypeFromInteger = "f64"
    case(NF90_BYTE)
       getDtypeFromInteger = "i8"
    case(NF90_SHORT)
       getDtypeFromInteger = "i16"
    case(NF90_INT)
       getDtypeFromInteger = "i32"
    case(NF90_INT64)
       getDtypeFromInteger = "i64"
    case default
       write(*,*) "Datatype not understood: ", dtype
       stop 1
    end select
  end function getDtypeFromInteger

  function getCreationMode(cmode)
    character(*), intent(in), optional :: cmode
    integer(i4) :: getCreationMode
    character(256) :: mode

    if (.not. (present(cmode))) then
      mode = "NETCDF4"
    else
      mode = cmode
    end if

    select case(trim(mode))
    case ("NETCDF4")
      getCreationMode = NF90_NETCDF4
    case ("SHARE")
      getCreationMode = NF90_SHARE
    case ("CLASSIC")
      getCreationMode = NF90_CLASSIC_MODEL
    case ("HDF5")
      getCreationMode = NF90_HDF5
    case ("64BIT_OFFSET")
      getCreationMode = NF90_64BIT_OFFSET
    case default
      print*, "Creation mode not understood: " // trim(mode)
      stop 1
    end select

  end function getCreationMode

  subroutine check(status, msg)
    integer(i4), intent(in) :: status
    character(*), intent(in) :: msg

    if (status /= NF90_NOERR) then
      write(*, *) msg
      write(*, *) nf90_strerror(status)
      stop 1
    end if
  end subroutine check

end module mo_netcdf