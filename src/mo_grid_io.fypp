#:include "common.fypp"
#:set GRID_IO_REAL_KINDS_TYPES = REAL_KINDS_TYPES
#:set GRID_IO_INT_KINDS_TYPES = INT_KINDS_TYPES
#:set GRID_IO_ALL_KINDS_TYPES = GRID_IO_REAL_KINDS_TYPES + GRID_IO_INT_KINDS_TYPES
#:set GRID_IO_ALL_KINDS = [pair[0] for pair in GRID_IO_ALL_KINDS_TYPES]
#!
#:def render_out_var_update(kind, type)
  !> \brief Update output_variable (non-layered)
  subroutine out_var_update_${kind}$(self, data)
    implicit none
    class(output_variable), intent(inout) :: self
    ${type}$, intent(in), dimension(:) :: data !< data for current time step
    if (self%layered) call error_message("output_variable: layered data requires update_layered: ", self%name)
    if (.not.allocated(self%data_${kind}$)) call error_message("output_variable: wrong kind: ", self%name, ", ", self%kind, "=/=${kind}$")
    if (size(data) /= self%grid%ncells) call error_message("output_variable: data size mismatch: ", self%name)
    self%data_${kind}$ = self%data_${kind}$ + data
    self%counter = self%counter + 1_i4
  end subroutine out_var_update_${kind}$

  !> \brief Update output_variable (layered)
  subroutine out_var_update_layered_${kind}$(self, data)
    implicit none
    class(output_variable), intent(inout) :: self
    ${type}$, intent(in), dimension(:,:) :: data !< data for current time step (cell, layer)
    if (.not.self%layered) call error_message("output_variable: non-layered data requires update: ", self%name)
    if (size(data,2) /= self%nlayers) call error_message("output_variable: layered data dimension mismatch: ", self%name)
    if (size(data,1) /= self%grid%ncells) call error_message("output_variable: layered data cell count mismatch: ", self%name)
    if (.not.allocated(self%data_layered_${kind}$)) call error_message("output_variable: wrong kind for layered data: ", self%name)
    self%data_layered_${kind}$ = self%data_layered_${kind}$ + data
    self%counter = self%counter + 1_i4
  end subroutine out_var_update_layered_${kind}$
#:enddef
#!
#:def render_output_update(kind, type)
  !> \brief Update a variable
  !> \details Add the array given as actual argument to the derived type's component 'data'
  subroutine output_update_${kind}$(self, name, data)
    implicit none
    class(output_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, intent(in), dimension(:) :: data !< data for current time step
    call self%vars(var_index(self%vars, name, "output%update"))%update(data)
  end subroutine output_update_${kind}$

  !> \brief Update a layered variable
  subroutine output_update_layered_${kind}$(self, name, data)
    implicit none
    class(output_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, intent(in), dimension(:,:) :: data !< data for current time step (cell, layer)
    call self%vars(var_index(self%vars, name, "output%update_layered"))%update_layered(data)
  end subroutine output_update_layered_${kind}$
#:enddef
#!
#:def render_in_var_read(kind, type)
  !> \brief read from input variable
  subroutine in_var_read_${kind}$(self, flip_y, t_index, data)
    implicit none
    class(input_variable), intent(inout) :: self
    logical, intent(in) :: flip_y !< flip data along y-axis
    integer(i4), intent(in), optional :: t_index !< current time step
    ${type}$, dimension(:, :), intent(out) :: data !< read data
    integer(i4), allocatable :: start(:), cnt(:)
    if (self%layered) call error_message("input_variable: layered data requires layered read: ", self%name)
    if (.not.self%static) then
      if (.not.present(t_index)) call error_message("input%read: temporal variable need a time: ", self%name)
      if (t_index==0_i4) call error_message("input%read: temporal variable need a time: ", self%name)
    end if
    allocate(start(self%rank), source=1_i4)
    allocate(cnt(self%rank), source=1_i4)
    cnt(1) = self%grid%nx
    cnt(2) = self%grid%ny
    if (.not.self%static) start(3) = t_index
    call self%nc%readInto(data, start=start, cnt=cnt)
    deallocate(start, cnt)
    if (flip_y) call flip(data, idim=2)
  end subroutine in_var_read_${kind}$
#:enddef
#!
#:def render_in_var_read_layered(kind, type)
  !> \brief read from layered input variable
  subroutine in_var_read_layered_${kind}$(self, flip_y, t_index, data)
    implicit none
    class(input_variable), intent(inout) :: self
    logical, intent(in) :: flip_y !< flip data along y-axis
    integer(i4), intent(in), optional :: t_index !< current time step
    ${type}$, dimension(:,:,:), intent(out) :: data !< read data (nx, ny, layer)
    integer(i4), allocatable :: start(:), cnt(:)
    if (.not.self%layered) call error_message("input_variable: variable not layered: ", self%name)
    if (.not.self%static) then
      if (.not.present(t_index)) call error_message("input%read_layered: temporal variable need a time: ", self%name)
      if (t_index==0_i4) call error_message("input%read_layered: temporal variable need a time: ", self%name)
    end if
    allocate(start(self%rank), source=1_i4)
    allocate(cnt(self%rank), source=1_i4)
    cnt(1) = self%grid%nx
    cnt(2) = self%grid%ny
    cnt(3) = self%nlayers
    if (.not.self%static) start(4) = t_index
    call self%nc%readInto(data, start=start, cnt=cnt)
    deallocate(start, cnt)
    if (flip_y) call flip(data, idim=2)
  end subroutine in_var_read_layered_${kind}$
#:enddef
#!
#:def render_in_var_read_chunk(kind, type)
  !> \brief read from input variable
  subroutine in_var_read_chunk_${kind}$(self, flip_y, t_index, t_size, data)
    implicit none
    class(input_variable), intent(inout) :: self
    logical, intent(in) :: flip_y !< flip data along y-axis
    integer(i4), intent(in) :: t_index !< current time step
    integer(i4), intent(in) :: t_size !< chunk size
    ${type}$, dimension(:,:,:), allocatable, intent(out) :: data !< read data
    integer(i4), allocatable :: start(:), cnt(:)
    if (self%static) call error_message("input%read_chunk: need temporal variable for chunk reading: ", self%name)
    if (self%layered) call error_message("input%read_chunk: layered variable requires layered chunk read: ", self%name)
    allocate(start(self%rank), source=1_i4)
    allocate(cnt(self%rank), source=1_i4)
    cnt(1) = self%grid%nx
    cnt(2) = self%grid%ny
    start(3) = t_index
    cnt(3) = t_size
    call self%nc%getData(data, start=start, cnt=cnt)
    deallocate(start, cnt)
    if (flip_y) call flip(data, idim=2)
  end subroutine in_var_read_chunk_${kind}$
#:enddef
#!
#:def render_in_var_read_chunk_layered(kind, type)
  !> \brief read chunk from layered input variable
  subroutine in_var_read_chunk_layered_${kind}$(self, flip_y, t_index, t_size, data)
    implicit none
    class(input_variable), intent(inout) :: self
    logical, intent(in) :: flip_y !< flip data along y-axis
    integer(i4), intent(in) :: t_index !< current time step
    integer(i4), intent(in) :: t_size !< chunk size
    ${type}$, dimension(:,:,:,:), allocatable, intent(out) :: data !< read data (nx,ny,layer,time)
    integer(i4), allocatable :: start(:), cnt(:)
    if (self%static) call error_message("input%read_chunk_layered: need temporal variable for chunk reading: ", self%name)
    if (.not.self%layered) call error_message("input%read_chunk_layered: variable not layered: ", self%name)
    if (self%nlayers <= 0_i4) call error_message("input%read_chunk_layered: layered variable without layers: ", self%name)
    allocate(start(self%rank), source=1_i4)
    allocate(cnt(self%rank), source=1_i4)
    cnt(1) = self%grid%nx
    cnt(2) = self%grid%ny
    cnt(3) = self%nlayers
    start(4) = t_index
    cnt(4) = t_size
    call self%nc%getData(data, start=start, cnt=cnt)
    deallocate(start, cnt)
    if (flip_y) call flip(data, idim=2)
  end subroutine in_var_read_chunk_layered_${kind}$
#:enddef
#!
#:def render_input_read_matrix(kind, type)
  !> \brief Read an input variable for a single time step
  subroutine input_read_matrix_${kind}$(self, name, data, current_time)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(self%grid%nx, self%grid%ny), intent(out) :: data !< read data
    type(datetime), intent(in), optional :: current_time !< current time step
    integer(i4) :: t_index
    t_index = 0_i4 ! indicate missing current_time
    if (present(current_time) .and. allocated(self%times)) t_index = self%time_index(current_time)
    call self%vars(var_index(self%vars, name, "input%read"))%read(flip_y=self%flip_y, t_index=t_index, data=data)
  end subroutine input_read_matrix_${kind}$
#:enddef
#!
#:def render_input_read_matrix_layered(kind, type)
  !> \brief Read a layered input variable for a single time step
  subroutine input_read_matrix_layered_${kind}$(self, name, data, current_time)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(self%grid%nx, self%grid%ny, self%nlayers), intent(out) :: data !< read data
    type(datetime), intent(in), optional :: current_time !< current time step
    integer(i4) :: t_index
    t_index = 0_i4
    if (present(current_time) .and. allocated(self%times)) t_index = self%time_index(current_time)
    call self%vars(var_index(self%vars, name, "input%read_layered"))%read_layered(flip_y=self%flip_y, t_index=t_index, data=data)
  end subroutine input_read_matrix_layered_${kind}$
#:enddef
#!
#:def render_input_read_pack(kind, type)
  !> \brief Read an input variable for a single time step
  subroutine input_read_pack_${kind}$(self, name, data, current_time)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(self%grid%ncells), intent(out) :: data !< read data
    type(datetime), intent(in), optional :: current_time !< current time step
    ${type}$, dimension(self%grid%nx, self%grid%ny) :: data_matrix
    call self%input_read_matrix_${kind}$(name, data_matrix, current_time)
    data = pack(data_matrix, self%grid%mask)
  end subroutine input_read_pack_${kind}$
#:enddef
#!
#:def render_input_read_pack_layered(kind, type)
  !> \brief Read a layered input variable for a single time step as packed array
  subroutine input_read_pack_layered_${kind}$(self, name, data, current_time)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(self%grid%ncells, self%nlayers), intent(out) :: data !< read data
    type(datetime), intent(in), optional :: current_time !< current time step
    ${type}$ :: data_matrix(self%grid%nx, self%grid%ny, self%nlayers)
    integer(i4) :: i
    call self%input_read_matrix_layered_${kind}$(name, data_matrix, current_time)
    do i = 1_i4, self%nlayers
      data(:, i) = pack(data_matrix(:,:,i), self%grid%mask)
    end do
  end subroutine input_read_pack_layered_${kind}$
#:enddef
#!
#:def render_input_read_chunk_matrix(kind, type)
  !> \brief Read an input variable for a given time frame
  subroutine input_read_chunk_matrix_${kind}$(self, name, data, timeframe_start, timeframe_end, times)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(:,:,:), allocatable, intent(out) :: data !< read data
    type(datetime), intent(in) :: timeframe_start !< start of time frame (excluding)
    type(datetime), intent(in) :: timeframe_end !< end of time frame (including)
    type(datetime), dimension(:), allocatable, intent(out), optional :: times !< timestamps for the data stack
    integer(i4) :: t_index, t_size
    if (self%static) call error_message("input%read_chunk: file has no time: ", self%path)
    call self%chunk_times(timeframe_start, timeframe_end, times, t_index, t_size)
    call self%input_read_chunk_by_ids_matrix_${kind}$(name, data, t_index, t_size)
  end subroutine input_read_chunk_matrix_${kind}$
#:enddef
#!
#:def render_input_read_chunk_matrix_layered(kind, type)
  !> \brief Read a layered input variable for a given time frame
  subroutine input_read_chunk_matrix_layered_${kind}$(self, name, data, timeframe_start, timeframe_end, times)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(:,:,:,:), allocatable, intent(out) :: data !< read data (nx,ny,layer,time)
    type(datetime), intent(in) :: timeframe_start !< start of time frame (excluding)
    type(datetime), intent(in) :: timeframe_end !< end of time frame (including)
    type(datetime), dimension(:), allocatable, intent(out), optional :: times !< timestamps for the data stack
    integer(i4) :: t_index, t_size
    if (self%static) call error_message("input%read_chunk_layered: file has no time: ", self%path)
    call self%chunk_times(timeframe_start, timeframe_end, times, t_index, t_size)
    call self%input_read_chunk_by_ids_matrix_layered_${kind}$(name, data, t_index, t_size)
  end subroutine input_read_chunk_matrix_layered_${kind}$
#:enddef
#!
#:def render_input_read_chunk_pack(kind, type)
  !> \brief Read an input variable for a given time frame
  subroutine input_read_chunk_pack_${kind}$(self, name, data, timeframe_start, timeframe_end, times)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(:,:), allocatable, intent(out) :: data !< read data
    type(datetime), intent(in) :: timeframe_start !< start of time frame (excluding)
    type(datetime), intent(in) :: timeframe_end !< end of time frame (including)
    type(datetime), dimension(:), allocatable, intent(out), optional :: times !< timestamps for the data stack
    ${type}$, dimension(:,:,:), allocatable :: data_matrix !< read data
    integer(i4) :: i, nt
    call self%input_read_chunk_matrix_${kind}$(name, data_matrix, timeframe_start, timeframe_end, times)
    nt = size(data_matrix, 3, kind=i4)
    allocate(data(self%grid%ncells, nt))
    do i = 1_i4, nt
      data(:,i) = pack(data_matrix(:,:,i), self%grid%mask)
    end do
  end subroutine input_read_chunk_pack_${kind}$
#:enddef
#!
#:def render_input_read_chunk_pack_layered(kind, type)
  !> \brief Read a layered input variable for a given time frame packed to 2-D
  subroutine input_read_chunk_pack_layered_${kind}$(self, name, data, timeframe_start, timeframe_end, times)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(:,:,:), allocatable, intent(out) :: data !< read data (ncells, layer, time)
    type(datetime), intent(in) :: timeframe_start !< start of time frame (excluding)
    type(datetime), intent(in) :: timeframe_end !< end of time frame (including)
    type(datetime), dimension(:), allocatable, intent(out), optional :: times !< timestamps for the data stack
    ${type}$, dimension(:,:,:,:), allocatable :: data_matrix !< read data
    integer(i4) :: i, j, nt
    call self%input_read_chunk_matrix_layered_${kind}$(name, data_matrix, timeframe_start, timeframe_end, times)
    nt = size(data_matrix,4, kind=i4)
    allocate(data(self%grid%ncells, self%nlayers, nt))
    do i = 1_i4, nt
      do j = 1_i4, self%nlayers
        data(:, j, i) = pack(data_matrix(:,:,j,i), self%grid%mask)
      end do
    end do
  end subroutine input_read_chunk_pack_layered_${kind}$
#:enddef
#!
#:def render_input_read_chunk_by_ids_matrix(kind, type)
  !> \brief Read an input variable for a given time frame
  subroutine input_read_chunk_by_ids_matrix_${kind}$(self, name, data, t_index, t_size)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(:,:,:), allocatable, intent(out) :: data !< read data
    integer(i4), intent(in) :: t_index !< start index of time frame
    integer(i4), intent(in) :: t_size !< chunk size
    if (self%static) call error_message("input%read_chunk: file has no time: ", self%path)
    call self%vars(var_index(self%vars, name, "input%read_chunk"))%read_chunk(self%flip_y, t_index, t_size, data)
  end subroutine input_read_chunk_by_ids_matrix_${kind}$
#:enddef
#!
#:def render_input_read_chunk_by_ids_matrix_layered(kind, type)
  !> \brief Read layered input variable chunk by ids
  subroutine input_read_chunk_by_ids_matrix_layered_${kind}$(self, name, data, t_index, t_size)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(:,:,:,:), allocatable, intent(out) :: data !< read data (nx,ny,layer,time)
    integer(i4), intent(in) :: t_index !< start index of time frame
    integer(i4), intent(in) :: t_size !< chunk size
    integer(i4) :: vidx
    if (self%static) call error_message("input%read_chunk_layered: file has no time: ", self%path)
    call self%vars(var_index(self%vars, name, "input%read_chunk_layered"))%read_chunk_layered(self%flip_y, t_index, t_size, data)
  end subroutine input_read_chunk_by_ids_matrix_layered_${kind}$
#:enddef
#!
#:def render_input_read_chunk_by_ids_pack(kind, type)
  !> \brief Read an input variable for a given time frame
  subroutine input_read_chunk_by_ids_pack_${kind}$(self, name, data, t_index, t_size)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(:,:), allocatable, intent(out) :: data !< read data
    integer(i4), intent(in) :: t_index !< start index of time frame
    integer(i4), intent(in) :: t_size !< chunk size
    ${type}$, dimension(:,:,:), allocatable :: data_matrix
    integer(i4) :: i
    call self%input_read_chunk_by_ids_matrix_${kind}$(name, data_matrix, t_index, t_size)
    allocate(data(self%grid%ncells, t_size))
    do i = 1_i4, t_size
      data(:,i) = pack(data_matrix(:,:,i), self%grid%mask)
    end do
  end subroutine input_read_chunk_by_ids_pack_${kind}$
#:enddef
#!
#:def render_input_read_chunk_by_ids_pack_layered(kind, type)
  !> \brief Read layered input variable chunk by ids packed
  subroutine input_read_chunk_by_ids_pack_layered_${kind}$(self, name, data, t_index, t_size)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: name !< name of the variable
    ${type}$, dimension(:,:,:), allocatable, intent(out) :: data !< read data (ncells, layer, time)
    integer(i4), intent(in) :: t_index !< start index of time frame
    integer(i4), intent(in) :: t_size !< chunk size
    ${type}$, dimension(:,:,:,:), allocatable :: data_matrix
    integer(i4) :: i, j
    call self%input_read_chunk_by_ids_matrix_layered_${kind}$(name, data_matrix, t_index, t_size)
    allocate(data(self%grid%ncells, self%nlayers, t_size))
    do i = 1_i4, t_size
      do j = 1_i4, self%nlayers
        data(:,j,i) = pack(data_matrix(:,:,j,i), self%grid%mask)
      end do
    end do
  end subroutine input_read_chunk_by_ids_pack_layered_${kind}$
#:enddef
#!
!> \file mo_grid_io.f90
!> \copydoc mo_grid_io

!> \brief Creates NetCDF input or output files for gridded 2D data.
!> \details NetCDF is first initialized and later on variables are put to the NetCDF.
!! \par Examples
!! - \ref 02_nc_output.f90 : \copybrief 02_nc_output.f90
!!   \include 02_nc_output.f90
!> \changelog
!! - David Schaefer       Aug 2015
!!   - major rewrite
!! - Stephan Thober       Oct 2015
!!   - adapted to mRM
!! - O. Rakovec, R. Kumar Nov 2017
!!   - added project description for the netcdf outputs
!! - S. Mueller,          Dec 2022
!!   - unified module for mHM and mRM
!! - S. Mueller,          May 2025
!!   - rewrote for FORCES and use general grid and datetime types
!!
!> \authors Matthias Zink
!> \authors Sebastian Müller
!> \date Apr 2013
!> \copyright Copyright 2005-\today, the CHS Developers, Sabine Attinger: All rights reserved.
!! FORCES is released under the LGPLv3+ license \license_note
module mo_grid_io

  use mo_kind, only : i1, i2, i4, i8, dp, sp
  use mo_constants, only : nodata_dp, nodata_sp, nodata_i1, nodata_i2, nodata_i4, nodata_i8
  use mo_grid, only: grid_t, cartesian, is_t_axis, check_uniform_axis, bottom_up, is_z_axis
  use mo_netcdf, only : NcDataset, NcDimension, NcVariable
  use mo_datetime, only : datetime, timedelta, delta_from_string, decode_cf_time_units, one_day, one_hour
  use mo_message, only : error_message, warn_message
  use mo_utils, only: is_close, flip
  implicit none

  public :: var, output_dataset, input_dataset, time_units_delta, time_index, var_index, time_values

  private

  !> \name Time Step Indicators
  !> \brief Constants to indicate the time stepping used in the in-/output files.
  !!@{
  integer(i4), public, parameter :: hourly = 1_i4 !< hourly
  integer(i4), public, parameter :: no_time = 0_i4 !< no time dimension available
  integer(i4), public, parameter :: daily = -1_i4 !< daily
  integer(i4), public, parameter :: monthly = -2_i4 !< monthly
  integer(i4), public, parameter :: yearly = -3_i4 !< yearly
  integer(i4), public, parameter :: varying = -9999_i4 !< no uniform time step
  !!@}
  !> \name Time Stamp Locators
  !> \brief Constants to define the timestamp location for the respective time span the in-/output files.
  !!@{
  integer(i4), public, parameter :: start_timestamp = 0_i4 !< timestamp at start of time span
  integer(i4), public, parameter :: center_timestamp = 1_i4 !< timestamp at center of time span
  integer(i4), public, parameter :: end_timestamp = 2_i4 !< timestamp at end of time span
  !!@}

  !> \class var
  !> \brief variable metadata definition for a 2D variable
  type var
    character(:), allocatable :: name          !< variable name in the NetCDF file (required)
    character(:), allocatable :: long_name     !< descriptive variable name
    character(:), allocatable :: standard_name !< standard variable name following CF-Conventions
    character(:), allocatable :: units         !< variable units
    character(:), allocatable :: dtype         !< variable data type in file ('f32', 'f64' (default), 'i8', 'i16', 'i32', 'i64')
    character(:), allocatable :: kind          !< kind of array for IO ('sp', 'dp' (real def.), 'i1', 'i2', 'i4' (int def.), 'i8')
    logical :: static = .false.                !< static variable (without time dimension)
    logical :: avg = .false.                   !< average data (only for writing)
    logical :: layered = .false.               !< variable is layered
  contains
    procedure, public :: meta => var_meta
  end type var

  !> \class output_variable
  !> \brief netcdf output variable container for a 2D variable
  type, extends(var) :: output_variable
    type(NcVariable) :: nc                           !< nc variable which contains the variable
    type(grid_t), pointer :: grid => null()          !< horizontal grid the data is defined on
    real(sp), allocatable :: data_sp(:)              !< store the data between writes (real)
    real(sp), allocatable :: data_layered_sp(:,:)    !< store layered data between writes (real)
    real(dp), allocatable :: data_dp(:)              !< store the data between writes (real)
    real(dp), allocatable :: data_layered_dp(:,:)    !< store layered data between writes (real)
    integer(i1), allocatable :: data_i1(:)           !< store the data between writes (integer)
    integer(i1), allocatable :: data_layered_i1(:,:) !< store layered data between writes (integer)
    integer(i2), allocatable :: data_i2(:)           !< store the data between writes (integer)
    integer(i2), allocatable :: data_layered_i2(:,:) !< store layered data between writes (integer)
    integer(i4), allocatable :: data_i4(:)           !< store the data between writes (integer)
    integer(i4), allocatable :: data_layered_i4(:,:) !< store layered data between writes (integer)
    integer(i8), allocatable :: data_i8(:)           !< store the data between writes (integer)
    integer(i8), allocatable :: data_layered_i8(:,:) !< store layered data between writes (integer)
    integer(i4) :: nlayers = 0_i4                    !< number of layers for buffered data
    integer(i4) :: rank = 0_i4                       !< rank of the variable
    integer(i4) :: counter = 0_i4                    !< count the number of updateVariable calls
    logical :: static_written = .false.              !< static variable was written
  contains
    procedure, public :: init => out_var_init
#:set OUT_VAR_UPDATE_PROCS = ["out_var_update_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
#:set OUT_VAR_UPDATE_LAYERED_PROCS = ["out_var_update_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
    procedure, private :: ${", ".join(OUT_VAR_UPDATE_PROCS)}$
    generic, public :: update => ${", ".join(OUT_VAR_UPDATE_PROCS)}$
    procedure, private :: ${", ".join(OUT_VAR_UPDATE_LAYERED_PROCS)}$
    generic, public :: update_layered => ${", ".join(OUT_VAR_UPDATE_LAYERED_PROCS)}$
    procedure, public :: write => out_var_write
  end type output_variable

  !> \class input_variable
  !> \brief netcdf input variable container for a 2D variable
  type, extends(var) :: input_variable
    type(NcVariable) :: nc                     !< nc variable which contains the variable
    type(grid_t), pointer :: grid => null()    !< horizontal grid the data is defined on
    integer(i4) :: nlayers = 0_i4              !< number of layers (0 for none)
    integer(i4) :: rank = 0_i4                 !< rank of the variable
  contains
    procedure, public :: init => in_var_init
#:set IN_VAR_READ_PROCS = ["in_var_read_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
#:set IN_VAR_READ_LAYERED_PROCS = ["in_var_read_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
    procedure, private :: ${", ".join(IN_VAR_READ_PROCS)}$
    procedure, private :: ${", ".join(IN_VAR_READ_LAYERED_PROCS)}$
    generic, public :: read => ${", ".join(IN_VAR_READ_PROCS)}$
    generic, public :: read_layered => ${", ".join(IN_VAR_READ_LAYERED_PROCS)}$
#:set IN_VAR_READ_CHUNK_PROCS = ["in_var_read_chunk_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
#:set IN_VAR_READ_CHUNK_LAYERED_PROCS = ["in_var_read_chunk_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
    procedure, private :: ${", ".join(IN_VAR_READ_CHUNK_PROCS)}$
    procedure, private :: ${", ".join(IN_VAR_READ_CHUNK_LAYERED_PROCS)}$
    generic, public :: read_chunk => ${", ".join(IN_VAR_READ_CHUNK_PROCS)}$
    generic, public :: read_chunk_layered => ${", ".join(IN_VAR_READ_CHUNK_LAYERED_PROCS)}$
  end type input_variable

  !> \class output_dataset
  !> \brief netcdf output dataset handler for gridded data
  !> \details Output dataset handler for static and temporal data.
  !! \par Examples
  !! - \ref 02_nc_output.f90 : \copybrief 02_nc_output.f90
  type output_dataset
    type(grid_t), pointer :: grid => null()       !< horizontal grid the data is defined on
    character(:), allocatable :: path             !< path to the NetCDF file
    type(NcDataset) :: nc                         !< NcDataset to write
    type(output_variable), allocatable :: vars(:) !< store all created (dynamic) variables
    integer(i4) :: nvars                          !< number of variables
    logical :: static                             !< only static variables (without time dimension)
    integer(i4) :: counter = 0_i4                 !< count written time steps
    type(datetime) :: previous_time               !< previous time steps for bounds
    type(datetime) :: start_time                  !< start time for time units
    type(timedelta) :: delta                      !< time step in time units definition
    integer(i4) :: timestamp = end_timestamp      !< time stamp reference (0: begin, 1: center, 2: end of time interval)
    integer(i4) :: deflate_level = 6_i4           !< deflate level for compression
    logical :: has_layer = .false.                !< dataset includes vertical layers
    integer(i4) :: nlayers = 0_i4                 !< number of layers in dataset
    logical :: positive_up = .false.              !< indicates upwards as positive direction for layers
    real(dp), allocatable :: layer(:)             !< reference depth/height per layer
    real(dp), allocatable :: layer_vertices(:)    !< layer bounds
  contains
    procedure, public :: init => output_init
    procedure, private :: define_z_axis => output_define_z_axis
#:set OUTPUT_UPDATE_PROCS = ["output_update_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
#:set OUTPUT_UPDATE_LAYERED_PROCS = ["output_update_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
    procedure, private :: ${", ".join(OUTPUT_UPDATE_PROCS)}$
    generic, public :: update => ${", ".join(OUTPUT_UPDATE_PROCS)}$
    procedure, private :: ${", ".join(OUTPUT_UPDATE_LAYERED_PROCS)}$
    generic, public :: update_layered => ${", ".join(OUTPUT_UPDATE_LAYERED_PROCS)}$
    procedure, public :: write => output_write
    procedure, public :: write_static => output_write_static
    procedure, public :: meta => output_meta
    procedure, public :: close => output_close
  end type output_dataset

  !> \class input_dataset
  !> \brief netcdf input dataset handler for gridded data
  !> \details Input dataset handler for static and temporal data.
  type input_dataset
    type(grid_t), pointer :: grid => null()       !< horizontal grid the data is defined on
    character(:), allocatable :: path             !< path to the NetCDF file
    type(NcDataset) :: nc                         !< NcDataset to write
    type(input_variable), allocatable :: vars(:)  !< store all created (dynamic) variables
    integer(i4) :: nvars                          !< number of variables
    logical :: static                             !< only static variables (without time dimension)
    logical :: flip_y                             !< whether to flip arrays along y-direction
    type(datetime) :: start_time                  !< start time for time units
    type(timedelta) :: delta                      !< time step in time units definition
    integer(i8) :: delta_sec                      !< time step in time units definition in seconds
    integer(i8) :: start_ord_sec                  !< ordinal seconds of start time
    integer(i4) :: timestep                       !< timestep in the file
    integer(i4), allocatable :: t_values(:)       !< time axis values for ends of time spans
    integer(i4), allocatable :: t_bounds(:)       !< time axis bound values
    type(datetime), allocatable :: times(:)       !< times for ends of time spans
    logical :: has_layer = .false.                !< dataset includes vertical layers
    integer(i4) :: nlayers = 0_i4                 !< number of layers in dataset
    logical :: positive_up = .false.              !< indicates upwards as positive direction for layers
    real(dp), allocatable :: layer(:)             !< reference depth/height per layer
    real(dp), allocatable :: layer_vertices(:)    !< layer bounds
  contains
    procedure, public :: init => input_init
    procedure, private :: define_layers => input_define_layers
    ! read
#:set INPUT_READ_PROCS = ["input_read_pack_{}".format(kind) for kind in GRID_IO_ALL_KINDS] + ["input_read_matrix_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
#:set INPUT_READ_LAYERED_PROCS = ["input_read_pack_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS] + ["input_read_matrix_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
    procedure, private :: ${", ".join(INPUT_READ_PROCS)}$
    generic, public :: read => ${", ".join(INPUT_READ_PROCS)}$
    procedure, private :: ${", ".join(INPUT_READ_LAYERED_PROCS)}$
    generic, public :: read_layered => ${", ".join(INPUT_READ_LAYERED_PROCS)}$
    ! read_chunk
#:set INPUT_READ_CHUNK_PROCS = ["input_read_chunk_pack_{}".format(kind) for kind in GRID_IO_ALL_KINDS] + ["input_read_chunk_matrix_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
#:set INPUT_READ_CHUNK_LAYERED_PROCS = ["input_read_chunk_pack_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS] + ["input_read_chunk_matrix_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
    procedure, private :: ${", ".join(INPUT_READ_CHUNK_PROCS)}$
    generic, public :: read_chunk => ${", ".join(INPUT_READ_CHUNK_PROCS)}$
    procedure, private :: ${", ".join(INPUT_READ_CHUNK_LAYERED_PROCS)}$
    generic, public :: read_chunk_layered => ${", ".join(INPUT_READ_CHUNK_LAYERED_PROCS)}$
    ! read_chunk_by_ids
#:set INPUT_READ_BY_IDS_PROCS = ["input_read_chunk_by_ids_pack_{}".format(kind) for kind in GRID_IO_ALL_KINDS] + ["input_read_chunk_by_ids_matrix_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
#:set INPUT_READ_BY_IDS_LAYERED_PROCS = ["input_read_chunk_by_ids_pack_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS] + ["input_read_chunk_by_ids_matrix_layered_{}".format(kind) for kind in GRID_IO_ALL_KINDS]
    procedure, private :: ${", ".join(INPUT_READ_BY_IDS_PROCS)}$
    generic, public :: read_chunk_by_ids => ${", ".join(INPUT_READ_BY_IDS_PROCS)}$
    procedure, private :: ${", ".join(INPUT_READ_BY_IDS_LAYERED_PROCS)}$
    generic, public :: read_chunk_by_ids_layered => ${", ".join(INPUT_READ_BY_IDS_LAYERED_PROCS)}$
    ! others
    procedure, public :: time_index => input_time_index
    procedure, public :: chunk_times => input_chunk_times
    procedure, public :: meta => input_meta
    procedure, public :: close => input_close
  end type input_dataset

contains

  !> \brief Determine time units delta from time stepping and selected timestamp.
  !> \return "minutes", "hours" or "days"
  function time_units_delta(timestep, timestamp) result(res)
    integer(i4), intent(in), optional :: timestep !< time step (-3, -2, -1, 0, 1 (default), >1)
    integer(i4), intent(in), optional :: timestamp !< time stamp reference (0: begin, 1: center, 2: end of time span (default))
    character(:), allocatable :: res
    integer(i4) :: step = hourly
    integer(i4) :: stamp = end_timestamp
    if (present(timestep)) step = timestep
    if (present(timestamp)) stamp = timestamp
    res = "hours" ! default
    if (stamp == center_timestamp) then
      if (step > no_time .and. mod(step, 2) == 1) res = "minutes"
    else
      if (step < no_time .and. step >= yearly ) res = "days"
      if (step > no_time .and. mod(step, 24) == 0) res = "days"
    end if
  end function time_units_delta

  !> \brief generate values for the time-dimension depending on given datetimes.
  subroutine time_values(start_time, previous_time, current_time, delta, timestamp, t_start, t_end, t_stamp)
    type(datetime), intent(in) :: start_time !< starting time in units
    type(datetime), intent(in) :: previous_time !< previous write-out time
    type(datetime), intent(in) :: current_time !< current write-out time
    type(timedelta), intent(in) :: delta !< time delta in units
    integer(i4), intent(in) ::  timestamp !< timestamp location selector
    integer(i4), intent(out) ::  t_start !< value for lower bound in time bounds
    integer(i4), intent(out) ::  t_end !< value for upper bound in time bounds
    integer(i4), intent(out) ::  t_stamp !< value for timestamp
    t_start = nint((previous_time - start_time) / delta, kind=i4)
    t_end = nint((current_time - start_time) / delta, kind=i4)
    ! maybe check if values are actually close the nearest integer (nint)
    select case( timestamp )
      case(start_timestamp)
        t_stamp = t_start
      case(center_timestamp)
        t_stamp = (t_start + t_end) / 2_i4
      case(end_timestamp)
        t_stamp = t_end
      case default
        call error_message("output_dataset%write: timestamp has no valid value.")
    end select
  end subroutine time_values

  !> \brief determine time-stepping time-dimension depending on given datetimes.
  subroutine time_stepping(t_var, timestamp, start_time, delta, timestep, t_values, t_bounds)
    type(NcVariable), intent(in) :: t_var !< time variable
    integer(i4), intent(in) :: timestamp !< timestamp location selector
    type(datetime), intent(out) :: start_time !< starting time in units
    type(timedelta), intent(out) :: delta !< time delta in units
    integer(i4), intent(out) ::  timestep !< time step indicator
    integer(i4), allocatable, dimension(:), intent(out) :: t_values !< time axis values for end of time spans
    integer(i4), allocatable, dimension(:), intent(out) :: t_bounds !< time axis bound values
    integer(i4), allocatable, dimension(:) :: tmp_arr, t_diffs
    type(timedelta) :: loc_delta ! local time delta in units
    type(datetime) :: loc_date
    integer(i4) :: dt, i
    real(dp) :: dt_dp
    logical :: is_monthly, is_yearly
    character(len=256) :: tmp_str
    type(NcVariable) :: tb_var
    integer(i4), allocatable, dimension(:,:) :: t_bnds

    call t_var%getAttribute("units", tmp_str)
    call decode_cf_time_units(trim(tmp_str), delta, start_time)
    ! check bounds
    if (t_var%hasAttribute("bounds")) then
      call t_var%getAttribute("bounds", tmp_str)
      tb_var = t_var%parent%getVariable(trim(tmp_str))
      call tb_var%getData(t_bnds)
      t_values = t_bnds(2, :) ! upper bound as reference value
    else if (timestamp == end_timestamp) then
      call t_var%getData(t_values)
    else if (timestamp == start_timestamp) then
      call t_var%getData(tmp_arr)
      if (size(tmp_arr) == 1_i4) then
        ! assume same step as with initial value
        allocate(t_values(1), source=2*tmp_arr(1))
      else
        allocate(t_values(size(tmp_arr)))
        t_values(:size(tmp_arr)-1) = tmp_arr(2:)
        ! assume last time-step has same size as second last
        t_values(size(tmp_arr)) = 2 * tmp_arr(size(tmp_arr)) - tmp_arr(size(tmp_arr)-1)
      end if
    else ! center or others
      call error_message("time_stepping: can't convert center of time-span to output time values")
    end if

    ! check t_values for stepping
    if (size(t_values)==1) then
      if (allocated(t_bnds)) then
        loc_delta = (t_bnds(2,1) - t_bnds(1,1)) * delta
      else
        loc_delta = delta
      end if
      if (loc_delta == one_day()) then
        timestep = daily
      else if (loc_delta == one_hour()) then
        timestep = hourly
      else
        call error_message("time_stepping: could not determine time step size")
      end if
    else
      if (allocated(t_bnds)) then
        t_diffs = t_bnds(2,:) - t_bnds(1,:)
      else
        t_diffs = t_values(2:) - t_values(:size(t_values)-1)
      end if
      dt = t_diffs(1)
      if (all(t_diffs==dt)) then
        loc_delta = dt * delta
        if (loc_delta == one_day()) then
          timestep = daily
        else if (loc_delta == one_hour()) then
          timestep = hourly
        else
          dt_dp = loc_delta / one_hour()
          timestep = nint(dt_dp, i4)
          if (.not.is_close(dt_dp, real(timestep, dp))) call error_message("time_stepping: could not determine time step size")
        end if
      else
        is_yearly = .true.
        is_monthly = .true.
        do i = 1_i4, size(t_values)
          loc_date = start_time + t_values(i) * delta
          is_monthly = is_monthly .and. loc_date%is_new_month()
          is_yearly = is_yearly .and. loc_date%is_new_year()
        end do
        if (is_yearly) then
          timestep = yearly
        else if (is_monthly) then
          timestep = monthly
        else
          timestep = varying
        end if
      end if
    end if

    ! generate bounds values
    allocate(t_bounds(size(t_values) + 1))
    t_bounds(2:) = t_values
    if (allocated(t_bnds)) then
      t_bounds(1) = t_bnds(1,1)
    else
      ! guess lower bound
      loc_date = start_time + t_values(1) * delta
      select case(timestep)
        case(varying)
          t_bounds(1) = t_values(1) - 1_i4 ! one delta step before
        case(yearly)
          loc_delta = loc_date%previous_new_year() - start_time
          t_bounds(1) = int(loc_delta%total_seconds() / delta%total_seconds(), i4)
        case(monthly)
          loc_delta = loc_date%previous_new_month() - start_time
          t_bounds(1) = int(loc_delta%total_seconds() / delta%total_seconds(), i4)
        case(daily)
          loc_delta = loc_date%previous_new_day() - start_time
          t_bounds(1) = int(loc_delta%total_seconds() / delta%total_seconds(), i4)
        case default ! hour based delta
          loc_delta = loc_date - timestep * one_hour() - start_time
          t_bounds(1) = int(loc_delta%total_seconds() / delta%total_seconds(), i4)
      end select
    end if

  end subroutine time_stepping

  !> \brief get time index for current time
  integer(i4) function time_index(times, current_time, raise, found)
    type(datetime), dimension(:), intent(in) :: times !< available times
    type(datetime), intent(in) :: current_time !< current read time
    logical, intent(in), optional :: raise !< switch to raise error if time not found
    logical, intent(out), optional :: found !< time was found
    integer(i4) :: i
    logical :: found_ = .false.
    logical :: raise_ = .true.
    if (present(raise)) raise_ = raise
    do i = 1_i4, size(times)
      if (current_time == times(i)) then
        found_ = .true.
        exit
      end if
    end do
    if (.not.found_.and.raise_) call error_message("time_index: current time not available: ", current_time%str())
    if (.not.found_) i = 0_i4
    if (present(found)) found = found_
    time_index = i
  end function time_index

  !> \brief Get variable meta data.
  !> \return \ref var meta data definition
  type(var) function var_meta(this)
    class(var), intent(in) :: this
    if (allocated(this%name)) var_meta%name = this%name
    if (allocated(this%long_name)) var_meta%long_name = this%long_name
    if (allocated(this%standard_name)) var_meta%standard_name = this%standard_name
    if (allocated(this%units)) var_meta%units = this%units
    if (allocated(this%dtype)) var_meta%dtype = this%dtype
    if (allocated(this%kind)) var_meta%kind = this%kind
    var_meta%static = this%static
    var_meta%avg = this%avg
    var_meta%layered = this%layered
  end function var_meta

  !> \brief Get variable index in vars array.
  !> \return index
  integer(i4) function var_index(vars, name, method)
    class(var), dimension(:), intent(in) :: vars !< variables array
    character(*), intent(in) :: name !< name of the variable
    character(*), intent(in) :: method !< method calling this
    integer(i4) :: i
    var_index = 0_i4
    do i = 1_i4, size(vars)
      if (vars(i)%name == name) then
        var_index = i
        return
      end if
    end do
    call error_message(method, ": variable not present: ", name)
  end function var_index

  !> \brief initialize output_variable
  subroutine out_var_init(self, meta, nc, grid, dims, deflate_level)
    implicit none
    class(output_variable), intent(inout) :: self
    type(var), intent(in) :: meta !< variable definition
    type(NcDataset), intent(in) :: nc !< NcDataset to write
    type(grid_t), pointer, intent(in) :: grid !< grid definition
    type(NcDimension), dimension(:), intent(in) :: dims !< dimensions in the file
    integer(i4), intent(in) :: deflate_level !< deflate level for compression
    type(NcDimension), allocatable :: var_dims(:)
    logical :: has_layer_var, has_time
    integer(i4) :: idx, npoints

    self%name = meta%name
    self%static = meta%static
    self%avg = meta%avg
    self%layered = meta%layered
    self%nlayers = 0_i4
    self%dtype = "f64" ! default to double
    if (allocated(meta%dtype)) self%dtype = trim(meta%dtype)

    has_layer_var = self%layered
    has_time = .not.self%static
    self%rank = 2_i4
    if (has_layer_var) self%rank = self%rank + 1_i4
    if (has_time) self%rank = self%rank + 1_i4
    if (size(dims) < self%rank) then
      call error_message("output_variable: given dimensions not enough to setup variable: ", self%name)
    end if
    allocate(var_dims(self%rank))
    var_dims(1) = dims(1)
    var_dims(2) = dims(2)
    idx = 3
    if (has_layer_var) then
      var_dims(idx) = dims(3)
      self%nlayers = dims(3)%getLength()
      idx = idx + 1
      if (self%nlayers <= 1_i4) then
        self%layered = .false.
        self%nlayers = 0_i4
      end if
    end if
    if (.not.has_layer_var) self%layered = .false.
    if (has_time) then
      var_dims(idx) = dims(size(dims))
    end if
    self%nc = nc%setVariable(self%name, self%dtype, var_dims, deflate_level=deflate_level, shuffle=.true.)

    if (allocated(meta%long_name)) self%long_name = meta%long_name
    if (allocated(meta%standard_name)) self%standard_name = meta%standard_name
    if (allocated(meta%units)) self%units = meta%units

    if (allocated(self%long_name)) call self%nc%setAttribute("long_name", self%long_name)
    if (allocated(self%standard_name)) call self%nc%setAttribute("standard_name", self%standard_name)
    if (allocated(self%units)) call self%nc%setAttribute("units", self%units)

    self%grid => grid
    if (self%grid%has_aux_coords()) call self%nc%setAttribute("coordinates", "lat lon")

    ! default array kind follows the NetCDF dtype unless overridden by metadata
    select case(self%dtype)
      case("f32")
        call self%nc%setFillValue(nodata_sp)
        call self%nc%setAttribute("missing_value", nodata_sp)
        self%kind = "dp" ! double precision as default for real data
      case("f64")
        call self%nc%setFillValue(nodata_dp)
        call self%nc%setAttribute("missing_value", nodata_dp)
        self%kind = "dp" ! double precision as default for real data
      case("i8")
        call self%nc%setFillValue(nodata_i1)
        call self%nc%setAttribute("missing_value", nodata_i1)
        self%kind = "i4" ! 4 byte integers as default for int data
      case("i16")
        call self%nc%setFillValue(nodata_i2)
        call self%nc%setAttribute("missing_value", nodata_i2)
        self%kind = "i4" ! 4 byte integers as default for int data
      case("i32")
        call self%nc%setFillValue(nodata_i4)
        call self%nc%setAttribute("missing_value", nodata_i4)
        self%kind = "i4" ! 4 byte integers as default for int data
      case("i64")
        call self%nc%setFillValue(nodata_i8)
        call self%nc%setAttribute("missing_value", nodata_i8)
        self%kind = "i4" ! 4 byte integers as default for int data
      case default
        call error_message("output_variable: unsupported dtype: ", self%name, ": ", self%dtype)
    end select
    if (allocated(meta%kind)) then
      self%kind = meta%kind
      if ((self%dtype(1:1) == "f" .and. meta%kind(2:2) /= "p") .or. (self%dtype(1:1) == "i" .and. meta%kind(1:1) /= "i")) &
        call warn_message("output_variable: variable dtype and array kind will result in conversion: ", &
                          self%name, ", dtype: ", self%dtype, ", kind:", self%kind)
    end if
    select case(self%kind)
      case("sp")
        if (self%layered) then
          allocate(self%data_layered_sp(self%grid%ncells, self%nlayers), source=0.0_sp)
        else
          allocate(self%data_sp(self%grid%ncells), source=0.0_sp)
        end if
      case("dp")
        if (self%layered) then
          allocate(self%data_layered_dp(self%grid%ncells, self%nlayers), source=0.0_dp)
        else
          allocate(self%data_dp(self%grid%ncells), source=0.0_dp)
        end if
      case("i1")
        if (self%layered) then
          allocate(self%data_layered_i1(self%grid%ncells, self%nlayers), source=0_i1)
        else
          allocate(self%data_i1(self%grid%ncells), source=0_i1)
        end if
      case("i2")
        if (self%layered) then
          allocate(self%data_layered_i2(self%grid%ncells, self%nlayers), source=0_i2)
        else
          allocate(self%data_i2(self%grid%ncells), source=0_i2)
        end if
      case("i4")
        if (self%layered) then
          allocate(self%data_layered_i4(self%grid%ncells, self%nlayers), source=0_i4)
        else
          allocate(self%data_i4(self%grid%ncells), source=0_i4)
        end if
      case("i8")
        if (self%layered) then
          allocate(self%data_layered_i8(self%grid%ncells, self%nlayers), source=0_i8)
        else
          allocate(self%data_i8(self%grid%ncells), source=0_i8)
        end if
      case default
        call error_message("output_variable: unsupported kind: ", self%name, ": ", self%kind)
    end select
  end subroutine out_var_init

#:for kind, type in GRID_IO_ALL_KINDS_TYPES
  #:call render_out_var_update(kind, type)
  #:endcall

#:endfor
  !> \brief Write timestep to file
  !> \details Write the content of the derived types's component 'data' to file, average if necessary
  !> \changelog
  !! - Robert Schweppe Jun 2018
  !!   - refactoring and reformatting
  !! - Sebastian Müller Oct 2025
  !!   - support all int/float kinds and layered variables
  !> \authors Sebastian, Müller, David Schafer, Robert Schweppe
  !> \date June 2015
  subroutine out_var_write(self, t_index)
    implicit none
    class(output_variable), intent(inout) :: self
    !> index along the time dimension of the netcdf variable
    integer(i4), intent(in), optional :: t_index
    integer(i4) :: i
    integer(i4), allocatable :: start(:), cnt(:)
    if (self%static .and. self%static_written) return
    if (self%counter == 0_i4) call error_message("output_variable: no data was added before writing: ", self%name)
    if (.not.self%static) then
      if (.not.present(t_index)) call error_message("output_variable: no time index was given for temporal variable: ", self%name)
    end if
    allocate(start(self%rank), source=1_i4)
    allocate(cnt(self%rank), source=1_i4)
    cnt(1) = self%grid%nx
    cnt(2) = self%grid%ny
    if (.not.self%static) start(self%rank) = t_index
    select case(self%kind)
      case("sp")
        if (self%layered) then
          if (self%avg.and.self%counter>1_i4) self%data_layered_sp = self%data_layered_sp / real(self%counter, sp)
          do i = 1_i4, self%nlayers
            start(3) = i
            call self%nc%setData(unpack(self%data_layered_sp(:,i), self%grid%mask, nodata_sp), start=start, cnt=cnt)
          end do
          self%data_layered_sp = 0.0_sp
        else
          if (self%avg.and.self%counter>1_i4) self%data_sp = self%data_sp / real(self%counter, sp)
          call self%nc%setData(unpack(self%data_sp, self%grid%mask, nodata_sp), start=start, cnt=cnt)
          self%data_sp = 0.0_sp
        end if
      case("dp")
        if (self%layered) then
          if (self%avg.and.self%counter>1_i4) self%data_layered_dp = self%data_layered_dp / real(self%counter, dp)
          do i = 1_i4, self%nlayers
            start(3) = i
            call self%nc%setData(unpack(self%data_layered_dp(:,i), self%grid%mask, nodata_dp), start=start, cnt=cnt)
          end do
          self%data_layered_dp = 0.0_dp
        else
          if (self%avg.and.self%counter>1_i4) self%data_dp = self%data_dp / real(self%counter, dp)
          call self%nc%setData(unpack(self%data_dp, self%grid%mask, nodata_dp), start=start, cnt=cnt)
          self%data_dp = 0.0_dp
        end if
      case("i1")
        if (self%layered) then
          if (self%avg.and.self%counter>1_i4) self%data_layered_i1 = int(int(self%data_layered_i1, kind=i4) / self%counter, kind=i1)
          do i = 1_i4, self%nlayers
            start(3) = i
            call self%nc%setData(unpack(self%data_layered_i1(:,i), self%grid%mask, nodata_i1), start=start, cnt=cnt)
          end do
          self%data_layered_i1 = 0_i1
        else
          if (self%avg.and.self%counter>1_i4) self%data_i1 = int(int(self%data_i1, kind=i4) / self%counter, kind=i1)
          call self%nc%setData(unpack(self%data_i1, self%grid%mask, nodata_i1), start=start, cnt=cnt)
          self%data_i1 = 0_i1
        end if
      case("i2")
        if (self%layered) then
          if (self%avg.and.self%counter>1_i4) self%data_layered_i2 = int(int(self%data_layered_i2, kind=i4) / self%counter, kind=i2)
          do i = 1_i4, self%nlayers
            start(3) = i
            call self%nc%setData(unpack(self%data_layered_i2(:,i), self%grid%mask, nodata_i2), start=start, cnt=cnt)
          end do
          self%data_layered_i2 = 0_i2
        else
          if (self%avg.and.self%counter>1_i4) self%data_i2 = int(int(self%data_i2, kind=i4) / self%counter, kind=i2)
          call self%nc%setData(unpack(self%data_i2, self%grid%mask, nodata_i2), start=start, cnt=cnt)
          self%data_i2 = 0_i2
        end if
      case("i4")
        if (self%layered) then
          if (self%avg.and.self%counter>1_i4) self%data_layered_i4 = self%data_layered_i4 / self%counter
          do i = 1_i4, self%nlayers
            start(3) = i
            call self%nc%setData(unpack(self%data_layered_i4(:,i), self%grid%mask, nodata_i4), start=start, cnt=cnt)
          end do
          self%data_layered_i4 = 0_i4
        else
          if (self%avg.and.self%counter>1_i4) self%data_i4 = self%data_i4 / self%counter
          call self%nc%setData(unpack(self%data_i4, self%grid%mask, nodata_i4), start=start, cnt=cnt)
          self%data_i4 = 0_i4
        end if
      case("i8")
        if (self%layered) then
          if (self%avg.and.self%counter>1_i4) self%data_layered_i8 = self%data_layered_i8 / int(self%counter, i8)
          do i = 1_i4, self%nlayers
            start(3) = i
            call self%nc%setData(unpack(self%data_layered_i8(:,i), self%grid%mask, nodata_i8), start=start, cnt=cnt)
          end do
          self%data_layered_i8 = 0_i8
        else
          if (self%avg.and.self%counter>1_i4) self%data_i8 = self%data_i8 / int(self%counter, i8)
          call self%nc%setData(unpack(self%data_i8, self%grid%mask, nodata_i8), start=start, cnt=cnt)
          self%data_i8 = 0_i8
        end if
    end select
    if (allocated(start)) deallocate(start)
    if (self%static) self%static_written = .true.
    self%counter = 0_i4
  end subroutine out_var_write

  !> \brief initialize input_variable
  subroutine in_var_init(self, meta, nc, grid)
    implicit none
    class(input_variable), intent(inout) :: self
    type(var), intent(in) :: meta !< variable definition
    type(NcDataset), intent(in) :: nc !< NcDataset to write
    type(grid_t), pointer, intent(in) :: grid !< grid definition
    type(NcDimension), dimension(:), allocatable :: dims
    type(NcVariable) :: coord_var
    integer(i4) :: nx, ny, rnk, expected_rank
    character(len=256) :: tmp_str
    self%name = meta%name
    self%nc = nc%getVariable(self%name)
    self%grid => grid
    dims = self%nc%getDimensions()
    rnk = size(dims)
    self%rank = rnk
    if (rnk < 2_i4) call error_message("input_variable: given variable has too few dimensions: ", trim(nc%fname), ":", self%name)
    if (rnk > 4_i4) call error_message("input_variable: given variable has too many dimensions: ", trim(nc%fname), ":", self%name)
    nx = dims(1)%getLength()
    ny = dims(2)%getLength()
    if (nx /= grid%nx .or. ny /= grid%ny) call error_message("input_variable: variable not matching grid: ", self%name)

    self%layered = meta%layered
    self%static = meta%static
    self%nlayers = 0_i4
    expected_rank = 2_i4

    if (self%layered) then
      expected_rank = expected_rank + 1_i4
      if (rnk < expected_rank) call error_message("input_variable: z dimension missing for layered variable: ", self%name)
      if (.not.nc%hasVariable(trim(dims(3)%getName()))) then
        call error_message("input_variable: coordinate variable missing for z dimension: ", self%name)
      end if
      coord_var = nc%getVariable(trim(dims(3)%getName()))
      if (.not.is_z_axis(coord_var)) call error_message("input_variable: z axis not identified: ", self%name)
      self%nlayers = dims(3)%getLength()
      if (self%nlayers <= 0_i4) call error_message("input_variable: z dimension without layers: ", self%name)
    end if

    if (.not.self%static) then
      expected_rank = expected_rank + 1_i4
      if (rnk < expected_rank) call error_message("input_variable: time dimension missing for temporal variable: ", self%name)
      if (.not.nc%hasVariable(trim(dims(rnk)%getName()))) then
        call error_message("input_variable: coordinate variable missing for time dimension: ", self%name)
      end if
      coord_var = nc%getVariable(trim(dims(rnk)%getName()))
      if (.not.is_t_axis(coord_var)) call error_message("input_variable: time axis not identified: ", self%name)
    end if

    if (rnk /= expected_rank) call error_message("input_variable: rank mismatch: ", self%name)

    self%dtype = trim(self%nc%getDtype())
    select case(self%dtype(1:1))
      case("f")
        self%kind = "dp"
      case("i")
        self%kind = "i4"
      case default
        call error_message("input_variable: unsupported dtype: ", self%name, ": ", self%dtype)
    end select
    if (allocated(meta%dtype)) then
      if (meta%dtype/=self%dtype) &
        call warn_message("input_variable: variable dtype not as expected: ", &
                          self%name, ", ", meta%dtype, "=/=", self%dtype)
    end if

    if (allocated(meta%kind)) then
      self%kind = meta%kind
      if ((self%dtype(1:1) == "f" .and. meta%kind(2:2) /= "p") .or. (self%dtype(1:1) == "i" .and. meta%kind(1:1) /= "i")) &
        call warn_message("input_variable: variable dtype and array kind will result in conversion: ", &
                          self%name, ", dtype: ", self%dtype, ", kind:", self%kind)
    end if

    if (allocated(meta%standard_name)) self%standard_name = meta%standard_name
    if (self%nc%hasAttribute("standard_name")) then
      call self%nc%getAttribute("standard_name", tmp_str)
      self%standard_name = trim(tmp_str)
    end if
    if (allocated(meta%standard_name)) then
      if (meta%standard_name/=self%standard_name) &
        call warn_message("input_variable: variable standard name not as expected: ", &
                          self%name, ", ", meta%standard_name, "=/=", self%standard_name)
    end if

    if (allocated(meta%units)) self%units = meta%units
    if (self%nc%hasAttribute("units")) then
      call self%nc%getAttribute("units", tmp_str)
      self%units = trim(tmp_str)
    end if
    if (allocated(meta%units)) then
      if (meta%units/=self%units) &
        call warn_message("input_variable: variable units not as expected: ", &
                          self%name, ", ", meta%units, "=/=", self%units)
    end if

    ! don't check long-name
    if (allocated(meta%long_name)) self%long_name = meta%long_name
    if (self%nc%hasAttribute("long_name")) then
      call self%nc%getAttribute("long_name", tmp_str)
      self%long_name = trim(tmp_str)
    end if
  end subroutine in_var_init

#:for kind, type in GRID_IO_ALL_KINDS_TYPES
  #:call render_in_var_read(kind, type)
  #:endcall
  #:call render_in_var_read_layered(kind, type)
  #:endcall

#:endfor
#!
#:for kind, type in GRID_IO_ALL_KINDS_TYPES
  #:call render_in_var_read_chunk(kind, type)
  #:endcall
  #:call render_in_var_read_chunk_layered(kind, type)
  #:endcall

#:endfor
#!
  !> \brief Initialize output_dataset
  !> \details Create and initialize the output file handler.
  !> \authors Matthias Zink
  !> \authors Robert Schweppe
  !> \authors Sebastian Müller
  !> \date Apr 2013
  subroutine output_init(self, path, grid, vars, start_time, delta, timestamp, deflate_level, grid_double_precision, layer, layer_vertices, positive_up)
    implicit none
    class(output_dataset), intent(inout) :: self
    character(*), intent(in) :: path !< path to the file
    type(grid_t), pointer, intent(in) :: grid !< grid definition for this output file
    type(var), dimension(:), intent(in) :: vars !< variables of the output file
    type(datetime), intent(in), optional :: start_time !< reference time
    character(*), intent(in), optional :: delta !< time units delta ("minutes", "hours" (default), "days")
    integer(i4), intent(in), optional :: timestamp !< time stamp location in time span (0: begin, 1: center, 2: end (default))
    integer(i4), intent(in), optional :: deflate_level !< deflate level for compression
    logical, optional, intent(in) :: grid_double_precision !< whether to use double precision to store grid (default .true.)
    real(dp), intent(in), optional, dimension(:) :: layer !< layer depths/heights
    real(dp), intent(in), optional, dimension(:) :: layer_vertices !< bounds for layers
    logical, intent(in), optional :: positive_up !< sign convention for vertical axis (default .false., i.e. depth)

    character(:), allocatable :: units, units_dt
    type(NcDimension) :: t_dim, b_dim, x_dim, y_dim, z_dim
    type(NcDimension), allocatable :: dims(:)
    type(NcVariable) :: t_var
    logical :: double_precision_
    integer(i4) :: i, nd, idx

    self%path = trim(path)
    self%nc = NcDataset(self%path, "w")
    self%grid => grid
    self%counter = 0_i4
    self%nlayers = 0_i4

    self%deflate_level = 6_i4
    if (present(deflate_level)) self%deflate_level = deflate_level
    self%timestamp = end_timestamp
    if (present(timestamp)) self%timestamp = timestamp

    self%positive_up = .false.
    if (present(positive_up)) self%positive_up = positive_up
    if (allocated(self%layer)) deallocate(self%layer)
    if (allocated(self%layer_vertices)) deallocate(self%layer_vertices)
    self%has_layer = .false.
    if (present(layer)) then
      if (.not.present(layer_vertices)) call error_message("output: layer_vertices missing while layer information provided")
      if (size(layer) == 0) call error_message("output: layer array must not be empty")
      if (size(layer) + 1 /= size(layer_vertices)) call error_message("output: number of layer vertices must be nlayers+1")
      allocate(self%layer(size(layer)), source=layer)
      allocate(self%layer_vertices(size(layer_vertices)), source=layer_vertices)
      self%has_layer = .true.
      self%nlayers = size(self%layer)
    else if (present(layer_vertices)) then
      call error_message("output: layer information incomplete without layer array")
    end if

    double_precision_ = .true.
    if (present(grid_double_precision)) double_precision_ = grid_double_precision

    ! write grid specification to file
    call self%grid%to_netcdf(self%nc, double_precision=grid_double_precision)

    if (self%has_layer) call self%define_z_axis(double_precision_)

    self%nvars = size(vars)
    if (.not.self%has_layer) then
      do i = 1_i4, self%nvars
        if (vars(i)%layered) call error_message("output: layered variable requires layer metadata: ", vars(i)%name)
      end do
    end if
    self%static = .true.
    do i = 1_i4, self%nvars
      self%static = self%static .and. vars(i)%static
    end do

    if (.not.self%static) then
      if (.not.present(start_time)) call error_message("output: if dataset is not static, a start_time is needed")
      units_dt = "hours"
      if (present(delta)) units_dt = trim(delta)
      self%previous_time = start_time
      self%start_time = start_time
      self%delta = delta_from_string(units_dt)
      units = units_dt // " since " // start_time%str()
      t_dim = self%nc%setDimension("time", 0)
      b_dim = self%nc%getDimension("bnds") ! added with grid
      t_var = self%nc%setVariable("time", "i32", [t_dim])
      call t_var%setAttribute("long_name", "time")
      call t_var%setAttribute("standard_name", "time")
      call t_var%setAttribute("axis", "T")
      call t_var%setAttribute("units", units)
      call t_var%setAttribute("bounds", "time_bnds")
      t_var = self%nc%setVariable("time_bnds", "i32", [b_dim, t_dim])
    end if

    if (self%grid%coordsys==cartesian) then
      x_dim = self%nc%getDimension("x")
      y_dim = self%nc%getDimension("y")
    else
      x_dim = self%nc%getDimension("lon")
      y_dim = self%nc%getDimension("lat")
    end if

    nd = 2
    if (self%has_layer) nd = nd + 1
    if (.not.self%static) nd = nd + 1
    allocate(dims(nd))
    dims(1) = x_dim
    dims(2) = y_dim
    idx = 3
    if (self%has_layer) then
      z_dim = self%nc%getDimension("z")
      dims(idx) = z_dim
      idx = idx + 1
    end if
    if (.not.self%static) then
      dims(idx) = t_dim
    end if

    allocate(self%vars(self%nvars))
    do i = 1_i4, self%nvars
      if (vars(i)%layered .and. .not.self%has_layer) &
        call error_message("output_init: variable requires layer dimension but none defined: ", vars(i)%name)
      call self%vars(i)%init(vars(i), self%nc, self%grid, dims, self%deflate_level)
    end do
    deallocate(dims)
  end subroutine output_init

  subroutine output_define_z_axis(self, double_precision)
    implicit none
    class(output_dataset), intent(inout) :: self
    logical, intent(in) :: double_precision
    type(NcDimension) :: z_dim, b_dim
    type(NcVariable) :: z_var, zb_var
    real(dp), allocatable :: z_bounds(:,:)
    character(3) :: dtype

    dtype = "f32"
    if (double_precision) dtype = "f64"

    z_dim = self%nc%setDimension("z", size(self%layer))
    b_dim = self%nc%getDimension("bnds")
    z_var = self%nc%setVariable("z", dtype, [z_dim])
    zb_var = self%nc%setVariable("z_bnds", dtype, [b_dim, z_dim])
    call z_var%setAttribute("axis", "Z")
    call z_var%setAttribute("bounds", "z_bnds")
    if (self%positive_up) then
      call z_var%setAttribute("standard_name", "height")
      call z_var%setAttribute("positive", "up")
    else
      call z_var%setAttribute("standard_name", "depth")
      call z_var%setAttribute("positive", "down")
    end if

    allocate(z_bounds(2, size(self%layer)))
    z_bounds(1,:) = self%layer_vertices(:size(self%layer))
    z_bounds(2,:) = self%layer_vertices(2:)
    if (double_precision) then
      call z_var%setData(self%layer)
      call zb_var%setData(z_bounds)
    else
      call z_var%setData(real(self%layer, sp))
      call zb_var%setData(real(z_bounds, sp))
    end if
    deallocate(z_bounds)
    self%has_layer = .true.
    self%nlayers = size(self%layer)
  end subroutine output_define_z_axis

#:for kind, type in GRID_IO_ALL_KINDS_TYPES
  #:call render_output_update(kind, type)
  #:endcall

#:endfor
#!
  !> \brief Write all accumulated data.
  !> \details Write all accumulated and potentially averaged data to disk.
  !> \changelog
  !! - Robert Schweppe Jun 2018
  !!   - refactoring and reformatting
  !!
  !> \authors David Schaefer
  !> \date June 2015
  subroutine output_write(self, current_time)
    implicit none
    class(output_dataset), intent(inout) :: self
    type(datetime), intent(in), optional :: current_time !< end time of the current time span
    integer(i4) :: i, t_start, t_end, t_stamp
    type(NcVariable) :: t_var
    self%counter = self%counter + 1_i4
    ! add to time variable
    if (.not.self%static) then
      if (.not.present(current_time)) call error_message("output: no time was given: ", self%path)
      call time_values(self%start_time, self%previous_time, current_time, self%delta, self%timestamp, &
                       t_start, t_end, t_stamp) ! intent(out)
      t_var = self%nc%getVariable("time")
      call t_var%setData(t_stamp, [self%counter])
      t_var = self%nc%getVariable("time_bnds")
      call t_var%setData(t_start, [1, self%counter])
      call t_var%setData(t_end, [2, self%counter])
      self%previous_time = current_time
    end if
    ! write all variables
    do i = 1_i4, self%nvars
      call self%vars(i)%write(self%counter)
    end do
  end subroutine output_write

  !> \brief Write all accumulated static data.
  subroutine output_write_static(self)
    implicit none
    class(output_dataset), intent(inout) :: self
    integer(i4) :: i
    do i = 1_i4, self%nvars
      if (self%vars(i)%static) call self%vars(i)%write()
    end do
  end subroutine output_write_static

  !> \brief Get variable meta data.
  !> \return \ref var meta data definition
  type(var) function output_meta(self, name)
    implicit none
    class(output_dataset) :: self
    character(*), intent(in) :: name !< name of the variable
    output_meta = self%vars(var_index(self%vars, name, "output%meta"))%meta()
  end function output_meta

  !> \brief Close the file
  subroutine output_close(self)
    implicit none
    class(output_dataset) :: self
    integer(i4) :: i
    do i = 1_i4, self%nvars
      ! check if variables have buffered data that was not written
      if (self%vars(i)%counter > 0_i4) call warn_message("output%close: unwritten buffered data for variable: ", self%vars(i)%name)
    end do
    call self%nc%close()
    deallocate(self%vars)
    if (allocated(self%layer)) deallocate(self%layer)
    if (allocated(self%layer_vertices)) deallocate(self%layer_vertices)
  end subroutine output_close

  !> \brief Initialize input_dataset
  !> \details Create and initialize the input file handler.
  subroutine input_init(self, path, vars, grid, timestamp, grid_init_var)
    implicit none
    class(input_dataset), intent(inout) :: self
    character(*), intent(in) :: path !< path to the file
    type(grid_t), intent(in), pointer :: grid !< grid definition to check against
    type(var), dimension(:), intent(in) :: vars !< variables of the output file
    integer(i4), intent(in), optional :: timestamp !< time stamp location in time span (0: begin, 1: center, 2: end (default))
    !> nc variable name to determine the grid from (by default, grid is assumed to be already initialized)
    character(*), intent(in), optional :: grid_init_var
    type(NcDimension), allocatable :: dims(:)
    type(NcVariable) :: t_var
    integer(i4) :: i
    logical :: y_inc

    self%path = trim(path)
    self%nc = NcDataset(self%path, "r")
    self%grid => grid
    self%nlayers = 0_i4
    if (present(grid_init_var)) call self%grid%from_netcdf(self%nc, grid_init_var)
    self%nvars = size(vars)
    if (self%nvars == 0_i4) call error_message("input_dataset: no variables selected")

    self%positive_up = .false.
    self%has_layer = .false.
    if (allocated(self%layer)) deallocate(self%layer)
    if (allocated(self%layer_vertices)) deallocate(self%layer_vertices)

    allocate(self%vars(self%nvars))
    self%static = .true.
    self%timestep = no_time
    do i = 1_i4, self%nvars
      call self%vars(i)%init(vars(i), self%nc, self%grid)
      if (self%vars(i)%layered .and. .not.self%has_layer) call self%define_layers(self%vars(i))
      if (.not.self%vars(i)%static .and. self%static) then
        self%static = .false.
        dims = self%vars(i)%nc%getDimensions()
        t_var = self%nc%getVariable(trim(dims(size(dims))%getName()))
        call time_stepping(t_var, timestamp, self%start_time, self%delta, self%timestep, self%t_values, self%t_bounds)
        self%times = [(self%start_time + self%t_values(i) * self%delta, i=1_i4,size(self%t_values))]
        self%delta_sec = self%delta%total_seconds()
        self%start_ord_sec = int(self%start_time%date_to_ordinal(), i8) * 86400_i8 + int(self%start_time%day_second(), i8)
      end if
    end do
    if (allocated(dims)) deallocate(dims)
    dims = self%vars(1)%nc%getDimensions()
    if (self%nc%hasVariable(trim(dims(2)%getName()))) then
      call check_uniform_axis(self%nc%getVariable(trim(dims(2)%getName())), increasing=y_inc)
      self%flip_y = y_inc.neqv.(self%grid%y_direction==bottom_up)
    else
      self%flip_y = .false.
    end if

  end subroutine input_init

  subroutine input_define_layers(self, layer_var)
    implicit none
    class(input_dataset), intent(inout) :: self
    class(input_variable), intent(in) :: layer_var
    character(len=256) :: z_name, bounds_name, pos_attr
    type(NcVariable) :: z_var, zb_var
    character(:), allocatable :: dtype
    real(dp), allocatable :: bounds(:,:)
    type(NcDimension), allocatable :: vdims(:)
    integer(i4) :: nl, i

    if (self%has_layer) return
    if (.not.layer_var%layered) call error_message("input: layered metadata missing for variable: ", layer_var%name)
    nl = layer_var%nlayers
    if (nl <= 0_i4) call error_message("input: layered variable without layers: ", layer_var%name)
    self%nlayers = nl

    vdims = layer_var%nc%getDimensions()
    if (size(vdims) < 3_i4) call error_message("input: layered variable missing z dimension: ", layer_var%name)
    z_name = trim(vdims(3)%getName())
    if (.not.self%nc%hasVariable(z_name)) call error_message("input: layer axis variable not found: ", z_name)

    z_var = self%nc%getVariable(z_name)
    if (.not.is_z_axis(z_var)) call warn_message('input: axis variable missing axis="Z" attribute: ' // trim(z_name))

    call z_var%getData(self%layer)
    if (size(self%layer) /= nl) call error_message("input: layer axis size mismatch: ", z_name)

    if (z_var%hasAttribute("positive")) then
      call z_var%getAttribute("positive", pos_attr)
      self%positive_up = trim(pos_attr) == "up"
    end if

    allocate(self%layer_vertices(nl+1))
    if (z_var%hasAttribute("bounds")) then
      call z_var%getAttribute("bounds", bounds_name)
      zb_var = self%nc%getVariable(trim(bounds_name))
      call zb_var%getData(bounds)
      self%layer_vertices(:nl) = bounds(1_i4,:)
      self%layer_vertices(nl+1_i4) = bounds(2_i4,nl)
      deallocate(bounds)
    else
      ! by default, bounds start at 0 and have endpoints as reference values
      ! TODO: should we warn here?
      self%layer_vertices(1) = 0.0_dp
      self%layer_vertices(2_i4:nl+1_i4) = self%layer
    end if

    self%has_layer = .true.
    if (allocated(vdims)) deallocate(vdims)
  end subroutine input_define_layers

#:for kind, type in GRID_IO_ALL_KINDS_TYPES
  ! ${kind}$ -----

  #:call render_input_read_matrix(kind, type)
  #:endcall

  #:call render_input_read_matrix_layered(kind, type)
  #:endcall

  #:call render_input_read_pack(kind, type)
  #:endcall

  #:call render_input_read_pack_layered(kind, type)
  #:endcall

  #:call render_input_read_chunk_matrix(kind, type)
  #:endcall

  #:call render_input_read_chunk_matrix_layered(kind, type)
  #:endcall

  #:call render_input_read_chunk_pack(kind, type)
  #:endcall

  #:call render_input_read_chunk_pack_layered(kind, type)
  #:endcall

  #:call render_input_read_chunk_by_ids_matrix(kind, type)
  #:endcall

  #:call render_input_read_chunk_by_ids_matrix_layered(kind, type)
  #:endcall

  #:call render_input_read_chunk_by_ids_pack(kind, type)
  #:endcall

  #:call render_input_read_chunk_by_ids_pack_layered(kind, type)
  #:endcall

#:endfor
#!
  ! others ---

  !> \brief Get times array for selected chunk time frame
  subroutine input_chunk_times(self, timeframe_start, timeframe_end, times, t_index, t_size)
    implicit none
    class(input_dataset), intent(inout) :: self
    type(datetime), intent(in) :: timeframe_start !< start of time frame (excluding)
    type(datetime), intent(in) :: timeframe_end !< end of time frame (including)
    type(datetime), dimension(:), allocatable, intent(out), optional :: times !< timestamps for the data stack
    integer(i4), intent(out), optional :: t_index !< starting index of time frame
    integer(i4), intent(out), optional :: t_size !< chunk size of time frame
    integer(i4) :: t_start, t_end, t_cnt, t_id
    if (self%static) call error_message("input%chunk_times: file has no time: ", self%path)
    if (timeframe_start < self%times(1)) then
      t_start = 0_i4
    else
      t_start = self%time_index(timeframe_start)
    end if
    if (timeframe_end > self%times(size(self%times))) then
      t_end = size(self%times)
    else
      t_end = self%time_index(timeframe_end)
    end if
    t_cnt = t_end - t_start
    t_id = t_start + 1_i4 ! times array has endpoints as references for time-spans, so we start with the next one
    if (present(t_index)) t_index = t_id
    if (present(t_size)) t_size = t_cnt
    if (present(times)) allocate(times(t_cnt), source=self%times(t_id:t_end))
  end subroutine input_chunk_times

  !> \brief Get time index for interval containing selected time
  integer(i4) function input_time_index(self, current_time)
    implicit none
    class(input_dataset), intent(in) :: self
    type(datetime), intent(in) :: current_time !< current read time
    integer(i8) :: current_delta_sec
    integer(i4) :: t_val
    if (.not.allocated(self%times)) call error_message("input%time_index: file is static and has no time dimension")
    ! seconds since start date
    current_delta_sec = int(current_time%date_to_ordinal(), i8) * 86400_i8 + int(current_time%day_second(), i8) - self%start_ord_sec
    ! calculate time value for current time for time units in file
    t_val = int(current_delta_sec / self%delta_sec, i4) ! division with remainder
    if (mod(current_delta_sec, self%delta_sec) > 0_i8) t_val = t_val + 1_i4 ! next step if remaining sub-step time
    ! locate the value in the time values of the file
    if (t_val < self%t_bounds(1)) call error_message("input%time_index: read time not covered by file.")
    do input_time_index = 1_i4, size(self%t_values)
      if (self%t_bounds(input_time_index) < t_val .and. t_val <= self%t_bounds(input_time_index+1_i4)) return
    end do
    call error_message("input%time_index: read time not covered by file.")
  end function input_time_index

  !> \brief Get variable meta data.
  !> \return \ref var meta data definition
  type(var) function input_meta(self, name)
    implicit none
    class(input_dataset) :: self
    character(*), intent(in) :: name !< name of the variable
    input_meta = self%vars(var_index(self%vars, name, "input%meta"))%meta()
  end function input_meta

  !> \brief Close the file
  subroutine input_close(self)
    implicit none
    class(input_dataset) :: self
    call self%nc%close()
    deallocate(self%vars)
    if (allocated(self%times)) deallocate(self%times)
    if (allocated(self%t_values)) deallocate(self%t_values)
    if (allocated(self%layer)) deallocate(self%layer)
    if (allocated(self%layer_vertices)) deallocate(self%layer_vertices)
  end subroutine input_close

end module mo_grid_io
