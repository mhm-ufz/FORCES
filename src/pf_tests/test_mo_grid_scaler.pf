module test_mo_grid_scaler
  use funit
  use mo_grid, only: grid_t, cartesian, top_down, bottom_up
  use mo_grid_scaler, only: scaler_t, up_a_mean, up_h_mean, up_p_mean, up_min, up_max, up_sum, up_laf, up_fraction, down_nearest, down_split
  use mo_kind, only: i4, dp, i8
  use mo_constants, only: nodata_dp
  use mo_utils, only: flip, flipped, is_close
  ! use mo_netcdf, only: NcDataset, NcVariable, NcDimension
  implicit none

  private

  public :: test_regrid
  public :: test_downscale_modes
  public :: test_no_scaling_identity
  public :: test_stats_and_weight_count

contains

  @test
  subroutine test_regrid()

    implicit none
    type(grid_t), target :: cgrid, fgrid
    type(scaler_t) :: upscaler
    ! type(NcDataset) :: nc
    ! type(NcDimension) :: x_dim, y_dim
    ! type(NcVariable) :: var
    real(dp) :: t=1.0E-5_dp
    real(dp) :: ref_val
    integer(i4) :: xt, xb, yt, yb
    integer(i8) :: i
    real(dp), allocatable :: dem(:), dem_mat(:,:), cdem(:), cdem_mat(:,:), weights(:), cweights(:)
    integer(i4), allocatable :: lc(:), clc(:), lc_mat(:,:), clc_mat(:,:)
    real(dp), allocatable :: lc1(:), lc2(:), lc3(:), lcf_mat(:,:)

    call fgrid%from_ascii_file("./files/dem.asc")
    cgrid = fgrid%derive_grid(upscaling_factor=16)

    call upscaler%init(fgrid, cgrid)

    allocate(weights(fgrid%ncells))
    weights = fgrid%pack(upscaler%weights)
    allocate(cweights(cgrid%ncells))
    call upscaler%execute(weights, cweights, upscaling_operator=up_sum)
    @assertTrue(all(is_close(cweights, 1.0_dp)), message='check weights sum to 1')

    call fgrid%read_data("./files/dem.asc", dem_mat)
    call fgrid%read_data("./files/landcover.asc", lc_mat)

    ! nc = NcDataset("dem.nc", "w")
    ! call fgrid%to_netcdf(nc)
    ! x_dim = nc%getDimension("x")
    ! y_dim = nc%getDimension("y")
    ! var = nc%setVariable("dem", "f64", [x_dim, y_dim])
    ! call var%setFillValue(nodata_dp)
    ! call var%setAttribute("missing_value", nodata_dp)
    ! call var%setData(dem_mat)
    ! call nc%close()

    allocate(dem(fgrid%ncells))
    dem = fgrid%pack(dem_mat)
    allocate(cdem(cgrid%ncells))
    allocate(cdem_mat(cgrid%nx, cgrid%ny))

    ! nc = NcDataset("cdem.nc", "w")
    ! call cgrid%to_netcdf(nc)
    ! x_dim = nc%getDimension("x")
    ! y_dim = nc%getDimension("y")

    @assertEqual(cgrid%nx, 18, message='upscaling nx check')
    @assertEqual(cgrid%ny, 27, message='upscaling ny check')

    call upscaler%execute(dem, cdem)
    ! check arithmetic mean upscaling
    do i = 1_i8, cgrid%ncells
      call upscaler%coarse_bounds(i, xb, xt, yb, yt)
      ! cartesian grid can use n-subcells for weights
      ref_val = sum(dem_mat(xb:xt,yb:yt), fgrid%mask(xb:xt,yb:yt)) / upscaler%n_subcells(i)
      @assertEqual(cdem(i), ref_val, tolerance=t, message='upscaling arithmetic mean check')
    end do

    ! var = nc%setVariable("dem_mean", "f64", [x_dim, y_dim])
    ! call var%setFillValue(nodata_dp)
    ! call var%setAttribute("missing_value", nodata_dp)
    ! cdem_mat = cgrid%unpack(cdem)
    ! call var%setData(cdem_mat)

    call upscaler%execute(dem, cdem, upscaling_operator=up_p_mean, p=2.1_dp)
    ! check p-mean upscaling
    do i = 1_i8, cgrid%ncells
      call upscaler%coarse_bounds(i, xb, xt, yb, yt)
      ! cartesian grid can use n-subcells for weights
      ref_val = (sum(dem_mat(xb:xt,yb:yt) ** 2.1_dp, fgrid%mask(xb:xt,yb:yt)) / upscaler%n_subcells(i)) ** (1.0_dp / 2.1_dp)
      @assertEqual(cdem(i), ref_val, tolerance=t, message='upscaling p-mean check (p=2.1)')
    end do

    ! var = nc%setVariable("dem_pmean", "f64", [x_dim, y_dim])
    ! call var%setFillValue(nodata_dp)
    ! call var%setAttribute("missing_value", nodata_dp)
    ! cdem_mat = cgrid%unpack(cdem)
    ! call var%setData(cdem_mat)

    call upscaler%execute(dem, cdem, upscaling_operator=up_p_mean, p=0.0_dp)
    ! check g-mean upscaling
    do i = 1_i8, cgrid%ncells
      call upscaler%coarse_bounds(i, xb, xt, yb, yt)
      ! cartesian grid can use n-subcells for weights
      ref_val = exp(sum(log(dem_mat(xb:xt,yb:yt)), fgrid%mask(xb:xt,yb:yt)) / upscaler%n_subcells(i))
      @assertEqual(cdem(i), ref_val, tolerance=t, message='upscaling geometric mean check')
    end do

    ! var = nc%setVariable("dem_gmean", "f64", [x_dim, y_dim])
    ! call var%setFillValue(nodata_dp)
    ! call var%setAttribute("missing_value", nodata_dp)
    ! cdem_mat = cgrid%unpack(cdem)
    ! call var%setData(cdem_mat)

    call upscaler%execute(dem, cdem, upscaling_operator=up_h_mean)
    ! check h-mean upscaling
    do i = 1_i8, cgrid%ncells
      call upscaler%coarse_bounds(i, xb, xt, yb, yt)
      ! cartesian grid can use n-subcells for weights
      ref_val = 1.0_dp / (sum(1.0 / dem_mat(xb:xt,yb:yt), fgrid%mask(xb:xt,yb:yt)) / upscaler%n_subcells(i))
      @assertEqual(cdem(i), ref_val, tolerance=t, message='upscaling harmonic mean check')
    end do

    ! var = nc%setVariable("dem_hmean", "f64", [x_dim, y_dim])
    ! call var%setFillValue(nodata_dp)
    ! call var%setAttribute("missing_value", nodata_dp)
    ! cdem_mat = cgrid%unpack(cdem)
    ! call var%setData(cdem_mat)

    call upscaler%execute(dem, cdem, upscaling_operator=up_min)
    ! check min upscaling
    do i = 1_i8, cgrid%ncells
      call upscaler%coarse_bounds(i, xb, xt, yb, yt)
      ! cartesian grid can use n-subcells for weights
      ref_val = minval(dem_mat(xb:xt,yb:yt), mask=fgrid%mask(xb:xt,yb:yt))
      @assertEqual(cdem(i), ref_val, tolerance=t, message='upscaling min check')
    end do

    ! var = nc%setVariable("dem_min", "f64", [x_dim, y_dim])
    ! call var%setFillValue(nodata_dp)
    ! call var%setAttribute("missing_value", nodata_dp)
    ! cdem_mat = cgrid%unpack(cdem)
    ! call var%setData(cdem_mat)

    call upscaler%execute(dem, cdem, upscaling_operator=up_max)
    ! check max upscaling
    do i = 1_i8, cgrid%ncells
      call upscaler%coarse_bounds(i, xb, xt, yb, yt)
      ! cartesian grid can use n-subcells for weights
      ref_val = maxval(dem_mat(xb:xt,yb:yt), mask=fgrid%mask(xb:xt,yb:yt))
      @assertEqual(cdem(i), ref_val, tolerance=t, message='upscaling max check')
    end do

    ! var = nc%setVariable("dem_max", "f64", [x_dim, y_dim])
    ! call var%setFillValue(nodata_dp)
    ! call var%setAttribute("missing_value", nodata_dp)
    ! cdem_mat = cgrid%unpack(cdem)
    ! call var%setData(cdem_mat)

    allocate(lc(fgrid%ncells))
    lc = fgrid%pack(lc_mat)
    allocate(clc(cgrid%ncells))
    allocate(lc1(cgrid%ncells))
    allocate(lc2(cgrid%ncells))
    allocate(lc3(cgrid%ncells))
    call upscaler%execute(lc, clc, upscaling_operator=up_laf, vmin=1_i4, vmax=3_i4)
    call upscaler%execute(lc, lc1, upscaling_operator=up_fraction, class_id=1_i4)
    call upscaler%execute(lc, lc2, upscaling_operator=up_fraction, class_id=2_i4)
    call upscaler%execute(lc, lc3, upscaling_operator=up_fraction, class_id=3_i4)

    @assertTrue(all(is_close(lc1+lc2+lc3, 1.0_dp)), message='check fractions sum to 1')
    @assertEqual(count(clc==1)+count(clc==2)+count(clc==3), cgrid%ncells, message='check fraction counts')

    ! call nc%close()

  end subroutine test_regrid

  @test
  subroutine test_downscale_modes()
    implicit none
    type(grid_t), target :: coarse, fine
    type(scaler_t) :: scaler
    real(dp), allocatable :: dp_out(:)
    integer(i4), allocatable :: i_out(:)
    real(dp) :: cw
    real(dp) :: dp_in(2), dp_in_mat(2,1)
    integer(i4) :: i_in(2)
    integer(i4) :: xl, xu, yl, yu

    call coarse%init(nx=2, ny=1, cellsize=2.0_dp, coordsys=cartesian, y_direction=bottom_up)
    call fine%init(nx=4, ny=1, cellsize=1.0_dp, coordsys=cartesian, y_direction=bottom_up)
    call scaler%init(coarse, fine, downscaling_operator=down_split)

    dp_in = [2.0_dp, 6.0_dp]
    dp_in_mat = reshape(dp_in, [2,1])
    i_in = [1_i4, 3_i4]
    allocate(dp_out(fine%ncells), i_out(fine%ncells))

    call scaler%downscale_nearest(dp_in, dp_out)
    @assertEqual(dp_out, [2.0_dp, 2.0_dp, 6.0_dp, 6.0_dp], tolerance=1.0e-12_dp)

    call scaler%execute(dp_in, dp_out, downscaling_operator=down_nearest)
    @assertEqual(dp_out, [2.0_dp, 2.0_dp, 6.0_dp, 6.0_dp], tolerance=1.0e-12_dp)

    call scaler%execute(dp_in, dp_out, downscaling_operator=down_split)
    @assertEqual(dp_out(3), 6.0_dp, tolerance=1.0e-12_dp)

    call scaler%downscale_nearest(dp_in_mat, dp_out)
    @assertEqual(dp_out(2), 2.0_dp, tolerance=1.0e-12_dp)

    call scaler%downscale_nearest(i_in, i_out)
    @assertEqual(i_out, [1_i4, 1_i4, 3_i4, 3_i4])

    call scaler%execute(i_in, i_out, downscaling_operator=down_nearest)
    @assertEqual(i_out, [1_i4, 1_i4, 3_i4, 3_i4])

    call scaler%coarse_bounds(coarse_i=1, coarse_j=1, x_lb=xl, x_ub=xu, y_lb=yl, y_ub=yu)
    @assertEqual([xl, xu, yl, yu], [1_i4, 2_i4, 1_i4, 1_i4])

    call scaler%downscale_split(dp_in_mat, dp_out)
    cw = scaler%coarse_weights(1)
    @assertEqual(dp_out(1:2), [cw*dp_in_mat(1,1), cw*dp_in_mat(1,1)], tolerance=1.0e-12_dp)

    call scaler%downscale_split(dp_in, dp_out)
    @assertEqual(dp_out(1), cw*dp_in(1), tolerance=1.0e-12_dp)
  end subroutine test_downscale_modes

  @test
  subroutine test_no_scaling_identity()
    implicit none
    type(grid_t), target :: g1, g2
    type(scaler_t) :: scaler
    real(dp) :: data_mat(2,2)
    real(dp), allocatable :: packed_in(:), packed_out(:), unpacked(:,:)

    call g1%init(nx=2, ny=2, cellsize=1.0_dp, coordsys=cartesian, y_direction=bottom_up)
    call g2%init(nx=2, ny=2, cellsize=1.0_dp, coordsys=cartesian, y_direction=bottom_up)
    call scaler%init(g1, g2)

    data_mat = reshape([1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp], [2,2])
    packed_in = g1%pack(data_mat)
    allocate(packed_out(size(packed_in)))
    call scaler%execute(packed_in, packed_out)
    allocate(unpacked(2,2))
    call g2%unpack_into(packed_out, unpacked)

    @assertEqual(unpacked, data_mat, tolerance=1.0e-12_dp)
  end subroutine test_no_scaling_identity

  @test
  subroutine test_stats_and_weight_count()
    implicit none
    type(grid_t), target :: fine, coarse
    type(scaler_t) :: scaler
    real(dp) :: data(2,2)
    integer(i4) :: idata(2,2)
    real(dp), allocatable :: out(:), out_mat(:,:)
    real(dp), allocatable :: out_mat2(:,:)
    integer(i4), allocatable :: iout(:), i_mat(:,:)
    integer(i4) :: ci, cj
    real(dp), allocatable :: packed_dp(:)
    integer(i4), allocatable :: packed_i(:)

    call fine%init(nx=2, ny=2, cellsize=1.0_dp, coordsys=cartesian, y_direction=bottom_up)
    call coarse%init(nx=1, ny=1, cellsize=2.0_dp, coordsys=cartesian, y_direction=bottom_up)
    call scaler%init(fine, coarse, weight_mode=1_i4) ! weight_count

    data = reshape([1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp], [2,2])
    idata = reshape([1_i4, 2_i4, 3_i4, 4_i4], [2,2])
    allocate(out(coarse%ncells))

    call scaler%execute(data, out, upscaling_operator=7_i4) ! up_var
    @assertEqual(out(1), 230.0_dp, tolerance=1.0e-12_dp)

    call scaler%execute(data, out, upscaling_operator=8_i4) ! up_std
    @assertEqual(out(1), sqrt(230.0_dp), tolerance=1.0e-12_dp)

    allocate(iout(coarse%ncells))
    call scaler%execute(idata, iout, upscaling_operator=up_min)
    @assertEqual(iout(1), 1_i4)
    call scaler%execute(idata, iout, upscaling_operator=up_max)
    @assertEqual(iout(1), 4_i4)
    call scaler%execute(idata, iout, upscaling_operator=up_sum)
    @assertEqual(10.0_dp, real(iout(1), dp), tolerance=1.0e-12_dp)

    allocate(out_mat(coarse%nx, coarse%ny))
    call scaler%execute(idata, out_mat, upscaling_operator=up_a_mean)
    @assertEqual(10.0_dp, out_mat(1,1), tolerance=1.0e-12_dp)

    allocate(out_mat2(coarse%nx, coarse%ny))
    call scaler%execute(data, out_mat2) ! dp 2d -> 2d
    @assertEqual(out_mat2(1,1), 10.0_dp, tolerance=1.0e-12_dp)

    packed_dp = fine%pack(data)
    call scaler%execute(packed_dp, out_mat2) ! dp 1d -> 2d
    @assertEqual(out_mat2(1,1), 10.0_dp, tolerance=1.0e-12_dp)

    allocate(i_mat(coarse%nx, coarse%ny))
    packed_i = fine%pack(idata)
    call scaler%execute(packed_i, i_mat, upscaling_operator=up_sum) ! i4 1d -> 2d
    @assertEqual(i_mat(1,1), 10_i4)

    call scaler%execute(packed_i, out_mat2, upscaling_operator=up_sum) ! i4 -> dp 2d
    @assertEqual(out_mat2(1,1), 10.0_dp, tolerance=1.0e-12_dp)

    call scaler%coarse_ij(fine_i=2_i4, fine_j=1_i4, coarse_i=ci, coarse_j=cj)
    @assertEqual([ci, cj], [1_i4, 1_i4])
  end subroutine test_stats_and_weight_count

end module test_mo_grid_scaler
